{"data":{"markdownRemark":{"html":"<h4>进程概述</h4>\n<p>浏览器的多进程，以chrome为例</p>\n<ul>\n<li>\n<p>Browser进程</p>\n<ul>\n<li>控制chrome的用户界面。所谓的用户界面，指的是浏览器网页窗口上面的部分，包括：地址栏、书签、向前向后按钮等</li>\n<li>负责网络请求、文件访问等不可见的底层服务</li>\n<li>负责各页面管理，创建和销毁其他进程</li>\n</ul>\n</li>\n<li>\n<p>渲染进程</p>\n<ul>\n<li>渲染进程负责页面渲染、脚本处理等内容</li>\n<li>每个tab有一个自己的独立的渲染进程，这么做的好处是：1、如果某个tab崩溃，不会影响其他tab的正常运行；2、隔离每个tab，避免一些跨tab造成的安全问题</li>\n</ul>\n</li>\n<li>\n<p>插件进程</p>\n<ul>\n<li>负责插件处理</li>\n<li>每个插件对应于一个插件进程</li>\n</ul>\n</li>\n<li>\n<p>GPU进程</p>\n<ul>\n<li>负责GPU任务(GPU会负责处理来自各个应用的请求，并且在同一个界面上进行绘制)</li>\n</ul>\n</li>\n<li>\n<p>其他</p>\n<ul>\n<li>比如一些工具进程等</li>\n</ul>\n</li>\n</ul>\n<p>可以在chrome的任务管理器中查看各个进程，其中每一行为一个进程，而且可以看到每个进程 CPU和内存的使用情况</p>\n<hr>\n<h4>进程合作</h4>\n<p>以在chrome地址栏输入网址为例，说明浏览器各进程之前的合作的：</p>\n<ul>\n<li>在chrome地址栏输入网址，<strong>Browser进程</strong>中的<strong>UI线程</strong>获取输入内容，然后分辨这个输入是一个地址还是一个查询字符串，chrome的地址栏既可以直接访问网址也可以进行搜索引擎查询。若是一个地址，则说明接下来需要对此网址进行请求；否则表示应该请求对应搜索引擎</li>\n<li>\n<p><strong>Browser进程</strong>中的<strong>UI线程</strong>展示网络正在请求的指示器，比如loading图标等；<strong>Browser进程</strong>的<strong>network线程</strong>对响应网络进行请求处理，包括DNS查询、建立TCP连接等</p>\n<ul>\n<li>如果此时<strong>network线程</strong>收到一个重定向的服务器返回，则告知<strong>UI线程</strong>进行重定向，展示不同的网址，并对重定向网址进行网络请求</li>\n</ul>\n</li>\n<li>\n<p><strong>network线程</strong>收到服务端返回后，首先查看返回内容的<code class=\"language-text\">Content-Type</code>请求头，以确定返回内容的类型。由于<code class=\"language-text\">Content-Type</code>请求头可能丢失或错误，所以可能会进行<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types\">MIME_types 嗅探</a>。根据<code class=\"language-text\">Content-Type</code>及嗅探结果，确定返回内容的类型后，<strong>Browser进程</strong>会根据内容类型进行不同的处理。</p>\n<ul>\n<li>如果内容是HTML文件，则接下来会会把返回数据交给<strong>Render进程</strong>进行页面渲染如果内容是zip文件或其他文件等，意味着返回内容是待下载内容，则将数据传递给下载管理器</li>\n<li>类型的确定不是等到所有内容都下载完才进行，在收到需要的数据之后便可以进行。下面的几部也都是在接受数据的同时同步进行的。</li>\n</ul>\n</li>\n<li>\n<p>另外，在接收到返回内容后，也会对内容进行跨域等安全检查。如果确定内容没有问题，并且属于对应请求的网址，则<strong>network进程</strong>会告知<strong>UI进程</strong>数据加载结束，<strong>UI进程</strong>则会寻找一个<strong>Render线程</strong>来进行页面渲染</p>\n<ul>\n<li>为了节省时间，在进行网络请求期间，<strong>UI进程</strong>会提前确定好后续进行页面渲染的<strong>Render线程</strong>，当数据加载完毕后，则直接将数据交给之前已经准备好的<strong>Render线程</strong>。</li>\n<li>需要注意的是，如果页面被重定向到了一个对于现在域名跨域的域名，则需要另外一个<strong>Render进程</strong>进行渲染</li>\n</ul>\n</li>\n<li>通过以上步骤，数据在加载中，并且已经有准备好的页面渲染的<strong>Render线程</strong>，则<strong>Browser进程</strong>通过IPC将数据发送给<strong>Render进程</strong>，<strong>Render进程</strong>开始进行网页渲染。</li>\n<li>当<strong>Render进程</strong>结束渲染，执行完所有<code class=\"language-text\">onload</code>事件后，通过IPC告知<strong>Browser进程</strong>，<strong>Browser进程</strong>的<strong>UI线程</strong>展示停止\"加载中\"的指示，显示加载完成。</li>\n</ul>\n<hr>\n<p>参考内容</p>\n<p><a href=\"https://developers.google.com/web/updates/2018/09/inside-browser-part2\">浏览器内部运行机制</a></p>\n<p><a href=\"http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html\">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></p>","frontmatter":{"title":"浏览器内部：浏览器进程"}}},"pageContext":{"postName":"/post/浏览器内部：浏览器进程"}}