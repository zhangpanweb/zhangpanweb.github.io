<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=7.0.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="编程小记">
<meta name="keywords" content="JavaScript 前端">
<meta property="og:type" content="website">
<meta property="og:title" content="渊虹小站">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="渊虹小站">
<meta property="og:description" content="编程小记">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="渊虹小站">
<meta name="twitter:description" content="编程小记">






  <link rel="canonical" href="http://yoursite.com/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>渊虹小站</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">渊虹小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">无诗无生活，有诗有远方</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/17/Nextjs简介/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangpanweb"/>
      <meta itemprop="description" content="编程小记"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渊虹小站"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/17/Nextjs简介/" class="post-title-link" itemprop="url">Nextjs简介</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-17 11:03:24 / Modified: 11:35:06" itemprop="dateCreated datePublished" datetime="2019-02-17T11:03:24+08:00">2019-02-17</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文以一个项目为基础，简要介绍 Next 框架中的一些概念和简单使用方式。</p>
</blockquote>
<h4 id="模板项目"><a href="#模板项目" class="headerlink" title="模板项目"></a>模板项目</h4><p>本文基于的项目来自 Next 的官方教程，地址为：<a href="https://github.com/arunoda/learnnextjs-demo.git，采用`clean-url-ssr`分支。" target="_blank" rel="noopener">https://github.com/arunoda/learnnextjs-demo.git，采用`clean-url-ssr`分支。</a></p>
<h4 id="几个主要的概念"><a href="#几个主要的概念" class="headerlink" title="几个主要的概念"></a>几个主要的概念</h4><h5 id="渲染方式"><a href="#渲染方式" class="headerlink" title="渲染方式"></a>渲染方式</h5><p>Next 结合了服务端渲染和客户端渲染。首屏加载时采用服务端渲染，之后若用户点击链接进入到新的页面，对新的页面则使用客户端渲染。</p>
<h5 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h5><p>Next 中，首次请求采用的服务端渲染。服务端渲染指的是，在服务端生成 html 字符串，然后传递给客户端，客户端解析并展示从服务端获取的内容，并进行<a href="https://reactjs.org/docs/react-dom.html#hydrate" target="_blank" rel="noopener">hydrate</a>，增加事件处理等。服务端渲染，又可以分为两种方式：</p>
<ul>
<li>一种是采用 Next 自身的路由框架，直接在<code>page</code>文件夹中增加页面，请求的页面路径直接渲染出<code>page</code>文件夹下的页面。例如，在<code>/pages/index.js</code>中定义以下组件并导出，则可以直接在<code>localhost:3000</code>中看到通过服务端渲染展示出的页面，页面中只有一个<code>Hello world!</code>。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &lt;p&gt;Hello world!&lt;/p&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>另一种是自定义路由。通过 express 自定义路由，自定义路由会通过 express 框架的<code>res.render</code>进行服务端渲染，然后将结果返回给客户端，客户端直接呈现服务端渲染结果。比如<a href="https://github.com/arunoda/learnnextjs-demo/blob/4482c6e0f16acea394a7f632ce2cd1e29a492779/server.js#L15" target="_blank" rel="noopener">模板项目中的一个例子</a></li>
</ul>
<h5 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h5><p>在首页加载完成后，用户点击某个链接，导向新的页面，此时则加载对应页面的 JS 文件，将 JS 下载客户端后，在客户端进行渲染，展示页面内容。此时不再通过服务端生成页面，而是客户端加载 JS 并生成页面。</p>
<blockquote>
<p>Next 中的客户端加载是通过<code>Link</code>组件来完成的，通过在页面中使用<code>Link</code>组件，则可以是页面拦截直接的服务端请求，转而采用加载 JS，并进行客户端渲染。若直接使用<code>a</code>标签，则相当于直接转向新的页面，则此时还是会重新请求服务端，进行服务端渲染。</p>
</blockquote>
<h5 id="页面兼容两种渲染方式"><a href="#页面兼容两种渲染方式" class="headerlink" title="页面兼容两种渲染方式"></a>页面兼容两种渲染方式</h5><p>如上所述，由于 Next 将首页采用服务端渲染，而用户可能在每个页面进行刷新，此时这个页面则成为加载的首页，此时页面必须能够被进行服务端渲染，从而完成首页加载；而另一方面，每个页面都可能由另外一个页面从客户端点击后链接导入而来，此时页面则必须能够进行客户端渲染。综上，每个页面都必须兼容服务端渲染和客户端渲染方式。而 Next 中的页面天然具有这种能力。</p>
<h4 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h4><p>Next 定义了<code>getInitialProps</code>方法进行数据获取，它是一个静态方法，例子如下，</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  /pages/post.js</span></span><br><span class="line"><span class="keyword">const</span> Post = <span class="function">(<span class="params">props</span>) =&gt;</span> (</span><br><span class="line">  <span class="keyword">return</span> &lt;Layout&gt;</span><br><span class="line">    &lt;h1&gt;&#123;props.show.name&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;&#123;props.show.summary.replace(/&lt;[/]?p&gt;/g, '')&#125;&lt;/p&gt;</span><br><span class="line">    &lt;img src=&#123;props.show.image.medium&#125; /&gt;</span><br><span class="line">  &lt;/Layout&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Post.getInitialProps = async function (context) &#123;</span><br><span class="line">  const &#123; id &#125; = context.query;</span><br><span class="line">  const res = await fetch(`https://api.tvmaze.com/shows/$&#123;id&#125;`);</span><br><span class="line">  const show = await res.json();</span><br><span class="line">  return &#123; show &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Post;</span><br></pre></td></tr></table></figure>
<ul>
<li>服务端渲染。若请求 post，并进行服务端渲染，则服务端会先查看 Post 是否有定义<code>getInitialProps</code>方法，若有定义此方法，则使用定义的方法请求数据，并将数据放置在一个服务端渲染出的 html 页面中的一个 script 标签中（如下所示）。客户端加载 html 后会将此数据渲染进视图。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"__NEXT_DATA__"</span> <span class="attr">type</span>=<span class="string">"application/json"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  &#123;<span class="string">"props"</span>:&#123;<span class="string">"pageProps"</span>:&#123;<span class="string">"show"</span>:<span class="number">1</span>&#125;&#125;,<span class="string">"page"</span>:<span class="string">"/post"</span>,<span class="string">"query"</span>:&#123;<span class="string">"id"</span>:<span class="string">"900"</span>&#125;,<span class="string">"buildId"</span>:<span class="string">"development"</span>&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>客户端渲染。在进行客户端渲染时，渲染页面，会先通过<code>getInitialProps</code>请求数据，并将请求到的数据通过 props 传递给组件，组件进行对应渲染。</li>
</ul>
<h4 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h4><p>在页面跳转时，若需要传递数据，比如在列表页，点击某个链接，跳转至其详情页，则在详情页需要知道，需要展示哪个内容的详情，此时则需要传递给详情对应数据。在列表页，跳转如下</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link <span class="keyword">as</span>=&#123;<span class="string">`/p/<span class="subst">$&#123;show.id&#125;</span>`</span>&#125; href=&#123;<span class="string">`/post?id=<span class="subst">$&#123;show.id&#125;</span>`</span>&#125;&gt;</span><br><span class="line">  &lt;a&gt;&#123;show.name&#125;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Link&gt;</span><br></pre></td></tr></table></figure>
<p>则在详情页，获取此 id 的方式为：</p>
<ul>
<li>对于组件，通过 <code>withRouter</code>，在<code>router.query</code>中获取，如下</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Content = withRouter(<span class="function"><span class="params">props</span> =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;&#123;props.router.query.title&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;This is the blog post content.&lt;/</span>p&gt;</span><br><span class="line">    &lt;p&gt;Content props:&#123;<span class="built_in">JSON</span>.stringify(props)&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">));</span><br></pre></td></tr></table></figure>
<ul>
<li>对于<code>getInitialProps</code>方法，通过<code>context</code>方式获取，如下</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Post.getInitialProps = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; id &#125; = context.query;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">`https://api.tvmaze.com/shows/<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> show = <span class="keyword">await</span> res.json();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Fetched show:<span class="subst">$&#123;show.name&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123; show &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然，这两种方式获取的数据是相同的。</p>
<p>若采用自定义路由（如下代码），在对应页面，也可以通过上面的方式通过<code>router.query</code>和<code>context.query</code>获取<code>queryParams</code>中的数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.get(<span class="string">"/p/:id"</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> actualPage = <span class="string">"/post"</span>;</span><br><span class="line">  <span class="keyword">const</span> queryParams = &#123; <span class="attr">id</span>: req.params.id &#125;;</span><br><span class="line">  app.render(req, res, actualPage, queryParams);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/06/深入了解React中state和props的更新/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangpanweb"/>
      <meta itemprop="description" content="编程小记"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渊虹小站"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/06/深入了解React中state和props的更新/" class="post-title-link" itemprop="url">深入了解React中state和props的更新</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-01-06 17:58:56" itemprop="dateCreated datePublished" datetime="2019-01-06T17:58:56+08:00">2019-01-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-17 11:35:39" itemprop="dateModified" datetime="2019-02-17T11:35:39+08:00">2019-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/译文/" itemprop="url" rel="index"><span itemprop="name">译文</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>此文为译文，原文见：<a href="https://medium.com/react-in-depth/in-depth-explanation-of-state-and-props-update-in-react-51ab94563311" target="_blank" rel="noopener">https://medium.com/react-in-depth/in-depth-explanation-of-state-and-props-update-in-react-51ab94563311</a></p>
</blockquote>
<p>在上<a href="https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e" target="_blank" rel="noopener">一篇文章</a>中，我讲解了一些基础，这些基础是理解这篇文章中描述更新过程中的技术细节所必需的。</p>
<p>我讲述了在这篇文章中会用到的主要数据结构和概念，特别是 Fiber 节点、current 和 work-in-progress 树、副作用和副作用列表。我也提供了一个主要算法的概览，并说明了 render 阶段和 commit 阶段的不同点。如果你还没有阅读上一篇文章，我推荐你从那里开始。</p>
<p>我也介绍了一个简单的应用，只有一个按钮，点击后会增加渲染在屏幕上数字的大小。</p>
<p><img src="/images/react/Inside-Fiber/1.png" alt=""></p>
<p>它的实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      &lt;button key=<span class="string">"1"</span> onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        Update counter</span><br><span class="line">      &lt;<span class="regexp">/button&gt;,</span></span><br><span class="line"><span class="regexp">      &lt;span key="2"&gt;&#123;this.state.count&#125;&lt;/</span>span&gt;</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我给组件添加了<code>componentDidUpdate</code>生命周期方法，它将用于展示在 React 在 commit 阶段如添加影响，调用这个方法。</p>
<p>在这篇文章中，我想向你展示 React 如何处理状态更新并建立副作用列表。我们将带你看到在 render 和 commit 阶段的高级函数中发生了什么。</p>
<p>特别的，我们将看到在<code>completeWork</code>函数中，React 如何：</p>
<ul>
<li>更新<code>ClickCounter</code> <code>state</code>中的<code>count</code>属性</li>
<li>调用<code>render</code>方法来获得一个子元素列表并执行对比</li>
<li>更新<code>span</code>元素的属性</li>
</ul>
<p>和在<code>commitRoot</code>中，React：</p>
<ul>
<li>更新<code>span</code>元素的<code>textContent</code>属性</li>
<li>调用<code>componentDidUpdate</code>生命周期方法</li>
</ul>
<p>在那之前，让我们先快速看一下当我们在点击处理函数中调用<code>setState</code>方法时，工作时如何调度的。</p>
<p>注意，你不用理解这些也能使用 React，这篇文章时关于 React 内部是如何工作的。</p>
<h4 id="调度更新"><a href="#调度更新" class="headerlink" title="调度更新"></a>调度更新</h4><p>当我们点击按钮时，<code>click</code>事件被触发，React 执行被传入 button 属性的回调。在我们的应用中，它仅仅增加计数并更新状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 React 组件有一个与之相关联的<code>updater</code>，它作为一个桥梁，连接组件和 React 核心。这使得<code>setState</code>能够能够被 React DOM、ReactNative、服务端渲染和测试工具中被以不同的方式进行实现。</p>
<p>在这篇文章中，我们将看到 ReactDOM 中<code>updater</code>对象的实现，而 React DOM 中私用的则是 Fiber reconciler。对于<code>ClickCounter</code>组件来说，这个<code>updater</code>是<code>classComponentUpdater</code>。它负责获取一个 Fiber 实例、队列更新以及调度工作。</p>
<p>当更新被加入队列中，他们被加入到需要在一个 Fiber 节点上被处理的更新的队列中。在我们的例子中，与<code>ClickCounter</code>组件相关联的 Fiber 节点有以下结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    stateNode: <span class="keyword">new</span> ClickCounter,</span><br><span class="line">    type: ClickCounter,</span><br><span class="line">    updateQueue: &#123;</span><br><span class="line">         baseState: &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line">         firstUpdate: &#123;</span><br><span class="line">             next: &#123;</span><br><span class="line">                 payload: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123; <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125; &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         ...</span><br><span class="line">     &#125;,</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你所能够看到的，<code>updateQueue.firstUpdate.next.payload</code>中的函数时我们传入到<code>ClickCounter</code>组件<code>setState</code>中的回调。它代表的是，在 render 阶段需要被处理的第一个更新。</p>
<h4 id="处理-ClickCounter-Fiber-node-的更新"><a href="#处理-ClickCounter-Fiber-node-的更新" class="headerlink" title="处理 ClickCounter Fiber node 的更新"></a>处理 ClickCounter Fiber node 的更新</h4><p>我上篇文章中<a href="https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e" target="_blank" rel="noopener">有关工作循环的章节</a>解释了<code>nextUnitOfWork</code>全局变量的作用。具体来说，章节中降到了，这个变量包含一个引用，指向<code>workInProgress</code>树中有工作需要被执行的 Fiber 节点。当 React 遍历 Fiber 树时，它使用这个遍历来知道是否有其他 Fiber 节点有未被完成的工作。</p>
<p>让我们假设<code>setState</code>节点被调用了，React 把来自<code>setState</code>的回调增加到<code>ClickCounter</code>fiber 节点的<code>updateQueue</code>中，并且开始调度工作。React 进入 render 阶段。它从最高的<code>HostRoot</code>Fiber 节点开始，使用<code>renderRoot</code>方法来遍历树。然而，它会跳过已经被处理过的 Fiber 节点，直到发现一个有未处理工作的节点。在我们的例子中，只有一个 Fiber 节点有未完成工作，他就是<code>ClickCounter</code>Fiber 节点。</p>
<p>所有的工作都会在这个 Fiber 节点的克隆副本上进行，这个克隆父辈被存放在<code>alternate</code>属性上。如果这个 alternate 节点还没有被创建，则 React 会在处理更新前，调用<code>createWorkInProgress</code>方法创建副本。让我们假设，变量<code>nextUnitOfWork</code>中存放了一个 alternate <code>ClickCounter</code> Fiber 节点的引用。</p>
<h5 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h5><p>首先，我们的 Fiber 进入到<a href="https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberBeginWork.js#L1489" target="_blank" rel="noopener">beginWork</a>。</p>
<blockquote>
<p>因为这个方法会在一个树的每个 Fiber 节点上被执行，所以如果你想要 debug render 阶段，这个地方是一个打断点的好地方。我在这里打断点，并区检查一个 Fiber 节点的类型，来找到我需要的那个。</p>
</blockquote>
<p><code>beginWork</code>函数时一个大的<code>switch</code>语句，通过 Fiber 节点的 tag 来判断什么类型的工作需要在这个 Fiber 节点上被执行，然后执行对应的函数来处理工作。当<code>CountClicks</code>是一个类组件时，这个分支时这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">current$$<span class="number">1</span>, workInProgress, ...</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> FunctionalComponent: &#123;...&#125;</span><br><span class="line">        <span class="keyword">case</span> ClassComponent:</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> updateClassComponent(current$$<span class="number">1</span>, workInProgress, ...);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> HostComponent: &#123;...&#125;</span><br><span class="line">        <span class="keyword">case</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们进入到了<code>updateClassComponent</code>方法。根据这是组件的第一次渲染、或者时组件更新的恢复再或者是组件的更新，React 会创建一个实例、或者挂载这个组件再或者更新它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateClassComponent</span>(<span class="params">current, workInProgress, Component, ...</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line">    <span class="keyword">let</span> shouldUpdate;</span><br><span class="line">    <span class="keyword">if</span> (instance === <span class="literal">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// In the initial pass we might need to construct the instance.</span></span><br><span class="line">        constructClassInstance(workInProgress, Component, ...);</span><br><span class="line">        mountClassInstance(workInProgress, Component, ...);</span><br><span class="line">        shouldUpdate = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// In a resume, we'll already have an instance we can reuse.</span></span><br><span class="line">        shouldUpdate = resumeMountClassInstance(workInProgress, Component, ...);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shouldUpdate = updateClassInstance(current, workInProgress, ...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> finishClassComponent(current, workInProgress, Component, shouldUpdate, ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="处理-ClickCounter-Fiber-的更新"><a href="#处理-ClickCounter-Fiber-的更新" class="headerlink" title="处理 ClickCounter Fiber 的更新"></a>处理 ClickCounter Fiber 的更新</h5><p>我们已经有了一个<code>ClickCounter</code>组件的实例，所以我们进入到<code>updateClassInstance</code>方法中。这是 React 执行大部分类组件工作的地方。在这个函数中执行的重要操作，安装执行顺序排列如下：</p>
<ul>
<li>调用<code>UNSAFE_componentWillReceiveProps()</code>钩子（deprecated）</li>
<li>处理<code>updateQueue</code>中的更新，并产生一个新的状态</li>
<li>使用新状态调用<code>getDerivedStateFromProps</code>获得结果</li>
<li>调用<code>shouldComponentUpdate</code>来保证组件确实需要被更新；如果结果为 false，则跳过整个渲染阶段，包括在这个组件和其子组件上调用 render；否则则处理更新</li>
<li>调用<code>UNSAFE_componentWillUpdate</code>（depricated）</li>
<li>增加一个影响，用来出发<code>componentDidUpdate</code>生命周期钩子</li>
</ul>
<blockquote>
<p>虽然调用<code>componentDidUpdate</code>的影响时在 render 阶段被添加的，但是这个方法时在 commit 阶段被执行的。</p>
</blockquote>
<ul>
<li>在组件实例上更新<code>state</code>和<code>props</code></li>
</ul>
<blockquote>
<p>state 和 props 子 render 方法被调用之前在组件实例上被更新，因为 render 方法的结果往往取决于 state 和 props。如果不这样做，每次 render 方法都将返回相同的结果。</p>
</blockquote>
<p>下面是这个方法的一个简化版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateClassInstance</span>(<span class="params">current, workInProgress, ctor, newProps, ...</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> oldProps = workInProgress.memoizedProps;</span><br><span class="line">    instance.props = oldProps;</span><br><span class="line">    <span class="keyword">if</span> (oldProps !== newProps) &#123;</span><br><span class="line">        callComponentWillReceiveProps(workInProgress, instance, newProps, ...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> updateQueue = workInProgress.updateQueue;</span><br><span class="line">    <span class="keyword">if</span> (updateQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">        processUpdateQueue(workInProgress, updateQueue, ...);</span><br><span class="line">        newState = workInProgress.memoizedState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    applyDerivedStateFromProps(workInProgress, ...);</span><br><span class="line">    newState = workInProgress.memoizedState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> shouldUpdate = checkShouldComponentUpdate(workInProgress, ctor, ...);</span><br><span class="line">    <span class="keyword">if</span> (shouldUpdate) &#123;</span><br><span class="line">        instance.componentWillUpdate(newProps, newState, nextContext);</span><br><span class="line">        workInProgress.effectTag |= Update;</span><br><span class="line">        workInProgress.effectTag |= Snapshot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    instance.props = newProps;</span><br><span class="line">    instance.state = newState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shouldUpdate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码片段中，我移除了一些辅助代码。比如说，在调用生命周期周期方法或增加触发他们的影响时之前，React 会使用<code>typeof</code>操作符检查一个组件是否实现了这些方法。比如说，增加影响前，对<code>componentDidUpdate</code>方法的检查：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> instance.componentDidUpdate === <span class="string">"function"</span>) &#123;</span><br><span class="line">  workInProgress.effectTag |= Update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，我们知道了在 render 阶段，会有哪些操作在<code>ClickCounter</code>Fiber 节点上执行。让我们现在来看看这些操作如何更不 Fiber 节点上的值。当 React 开始工作时，<code>ClickCounter</code>对应的 Fiber 节点看起来类似于下面的样子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    effectTag: <span class="number">0</span>,</span><br><span class="line">    elementType: <span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span>,</span></span><br><span class="line">    firstEffect: null,</span><br><span class="line">    memoizedState: &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    type: <span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span>,</span></span><br><span class="line">    stateNode: &#123;</span><br><span class="line">        state: &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    updateQueue: &#123;</span><br><span class="line">        baseState: &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;,</span><br><span class="line">        firstUpdate: &#123;</span><br><span class="line">            next: &#123;</span><br><span class="line">                payload: <span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;…&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成工作后，FIber 节点将看起来像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    effectTag: <span class="number">4</span>,</span><br><span class="line">    elementType: <span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span>,</span></span><br><span class="line">    firstEffect: null,</span><br><span class="line">    memoizedState: &#123;<span class="attr">count</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    type: <span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span>,</span></span><br><span class="line">    stateNode: &#123;</span><br><span class="line">        state: &#123;<span class="attr">count</span>: <span class="number">1</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    updateQueue: &#123;</span><br><span class="line">        baseState: &#123;<span class="attr">count</span>: <span class="number">1</span>&#125;,</span><br><span class="line">        firstUpdate: <span class="literal">null</span>,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们花点时间来看下属性值的变化。</p>
<p>在更新被实施之后，<code>memoizedState</code>和<code>updateQueue</code>中<code>baseState</code>，count 属性的值变为了 1。React 也更新了<code>ClickCounter</code>组件实例中的状态。</p>
<p>在这时，在队列中已经没有更新，所以<code>firstUpdate</code>的值时<code>null</code>。另外，重要的是，我们更新了<code>effectTag</code>属性。它不再是 0，而是 4。4 的二进制是 100，也就是第三字节被设置了，而这正是<code>update</code>副作用 tag 的字节：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Update = <span class="number">0b00000000100</span>;</span><br></pre></td></tr></table></figure>
<p>总结来说，当处理父元素<code>ClickCounter</code>Fiber 节点时，React 会调用变更前生命周期方法，更新状态并定义相关的副作用。</p>
<h5 id="reconcililng-ClickCounter-Fiber-子元素"><a href="#reconcililng-ClickCounter-Fiber-子元素" class="headerlink" title="reconcililng ClickCounter Fiber 子元素"></a>reconcililng ClickCounter Fiber 子元素</h5><p>一旦上面说的都完成了，React 则会进入<code>finishClassComponent</code>。这是 React 调用一个组件实例 render 方法的地方，并且会将对比算法运用在组件返回的子元素上。有关这个概览可以在<a href="https://reactjs.org/docs/reconciliation.html#the-diffing-algorithm" target="_blank" rel="noopener">文档</a>中看到。相关部分如下：</p>
<blockquote>
<p>当对比两个相同类型的 React DOM 元素，React 检查他们两个的属性、保持其下相同的 DOM 节点，仅仅更新变更过的属性。</p>
</blockquote>
<p>如果深入了解，我们会发现，其实它对比的是 Fiber 节点和 React 元素。我不会深入到这些细节。我会单独写有关子 reconciliation 的文章。</p>
<blockquote>
<p>如果你很好奇里面的细节，你也可以去看<code>reconcileChildrenArray</code>方法，因为在我们的应用中，render 方法返回了一个 React 元素组成的数组。</p>
</blockquote>
<p>到这里，有两个需要注意的点。首先，当 React 进行子 reconciliation 过程时，它创建或更新从 render 方法返回子 React 元素的 Fiber 节点。<code>finishClassComponent</code>函数返回对 current Fiber 节点的第一个孩子的引用。这个引用会被赋值给<code>nextUnitOfWork</code>，并且在工作循环中被处理。其次，React 把在孩子上更新 props 的工作看作是在其父元素工作的一部分。这个过程，用到了来自 React 元素 render 方法返回的数据。</p>
<p>比如，在 React reconcile ClickCounter fiber 的孩子之前，span 元素对应的 Fiber 节点看起来是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    stateNode: <span class="keyword">new</span> HTMLSpanElement,</span><br><span class="line">    type: <span class="string">"span"</span>,</span><br><span class="line">    key: <span class="string">"2"</span>,</span><br><span class="line">    memoizedProps: &#123;<span class="attr">children</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    pendingProps: &#123;<span class="attr">children</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你所看到的，在<code>memoizedProps</code>和<code>pendingProps</code>中，<code>children</code>属性都是 0。下面是 span 元素 render 方法返回的结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span>(react.element);</span><br><span class="line">  key: <span class="string">"2"</span>;</span><br><span class="line">  props: &#123;</span><br><span class="line">    children: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ref: <span class="literal">null</span>;</span><br><span class="line">  type: <span class="string">"span"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你所看到的，Fiber 节点和返回的 React 元素的 props 是不同的。在用来创建 alernate Fiber 节点的<code>createWorkInProgress</code>方法中，React 会把更新后的属性从 React 元素复制到 Fiber 节点中。</p>
<p>所以，React 在 ClickCounter 组件上完成 reconcile 子元素后，span Fiber 节点将会有一个<code>pendingProps</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    stateNode: <span class="keyword">new</span> HTMLSpanElement,</span><br><span class="line">    type: <span class="string">"span"</span>,</span><br><span class="line">    key: <span class="string">"2"</span>,</span><br><span class="line">    memoizedProps: &#123;<span class="attr">children</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    pendingProps: &#123;<span class="attr">children</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后，当 React 在 span Fiber 节点上执行工作时，它会把它们复制给<code>memoizedProps</code>，并且增加影响来更新 DOM。</p>
<p>这就是 render 阶段，React 对 ClickCounter fiber 节点做的所有工作。因为 button 是 ClickCounter 的第一个孩子，所以它会被赋值给<code>nextUnitOfWork</code>变量。对于它来说，这里并没有需要做的事情，所以 React 会转向它的兄弟，也就是 span Fiber 节点。根据在<a href="https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e#25fb" target="_blank" rel="noopener">这里</a>描述的算法，这个转移发生在<code>completeUnitOfWork</code>方法中。</p>
<h5 id="处理-span-fiber-的更新"><a href="#处理-span-fiber-的更新" class="headerlink" title="处理 span fiber 的更新"></a>处理 span fiber 的更新</h5><p>所以，这时<code>nextUnitOfWork</code>指向 span fiber 的 alternate，并且 React 开始在它上面执行工作。和在 ClickCounter 执行工作的步骤类似，我们以<code>beginWork</code>方法开始。</p>
<p>因为我们的 span 节点是<code>HostComponent</code>类型，所以这次，在 switch 语句中，React 会采用以下分支：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">current$$<span class="number">1</span>, workInProgress, ...</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> FunctionalComponent: &#123;...&#125;</span><br><span class="line">        <span class="keyword">case</span> ClassComponent: &#123;...&#125;</span><br><span class="line">        <span class="keyword">case</span> HostComponent:</span><br><span class="line">          <span class="keyword">return</span> updateHostComponent(current, workInProgress, ...);</span><br><span class="line">        <span class="keyword">case</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它将以<code>updateHostComponent</code>方法结束。它对应于类组件的<code>updateClassComponent</code>方法。对于一个函数组件来说，它是<code>updateFunctionComponent</code>，等等。你可以在<code>ReactFiberBeginWork.js</code>中找到所有的这些方法。</p>
<h5 id="reconcile-span-fiber-的子元素"><a href="#reconcile-span-fiber-的子元素" class="headerlink" title="reconcile span fiber 的子元素"></a>reconcile span fiber 的子元素</h5><p>在我们的例子中，对于 span 节点，<code>updateHostComponent</code>中并没有什么重要的内容。</p>
<h5 id="完成-span-Fiber-节点的工作"><a href="#完成-span-Fiber-节点的工作" class="headerlink" title="完成 span Fiber 节点的工作"></a>完成 span Fiber 节点的工作</h5><p>一旦<code>beginWork</code>结束，这个节点进入到<code>completeWork</code>方法中。但是在这之前，React 需要更新 span fiber 的<code>memoizedProps</code>。你应该还记得当在 ClickCounter 组件上 reconcile 孩子时，React 更新了 span Fiber 节点的<code>pendingProps</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    stateNode: <span class="keyword">new</span> HTMLSpanElement,</span><br><span class="line">    type: <span class="string">"span"</span>,</span><br><span class="line">    key: <span class="string">"2"</span>,</span><br><span class="line">    memoizedProps: &#123;<span class="attr">children</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    pendingProps: &#123;<span class="attr">children</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，一旦 span fiber 的<code>beginWork</code>完成，React 会更新<code>pendingProps</code>到对应的<code>memoizedProps</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    next = beginWork(current$$<span class="number">1</span>, workInProgress, nextRenderExpirationTime);</span><br><span class="line">    workInProgress.memoizedProps = workInProgress.pendingProps;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后它会调用<code>completeWork</code>方法，它和<code>beginWork</code>类似，都是一个大的<code>swtich</code>语句：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">current, workInProgress, ...</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> FunctionComponent: &#123;...&#125;</span><br><span class="line">        <span class="keyword">case</span> ClassComponent: &#123;...&#125;</span><br><span class="line">        <span class="keyword">case</span> HostComponent: &#123;</span><br><span class="line">            ...</span><br><span class="line">            updateHostComponent(current, workInProgress, ...);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 span 节点是<code>HostComponent</code>，所以它会运行<code>updateHostComponent</code>方法。在这个方法中，React 大致会执行以下动作：</p>
<ul>
<li>准备 DOM 更新</li>
<li>把它们增加到 span fiber 的<code>updateQueue</code>中</li>
<li>增加更新 DOM 的影响</li>
</ul>
<p>在操作执行之前，span 节点看起来像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    stateNode: <span class="keyword">new</span> HTMLSpanElement,</span><br><span class="line">    type: <span class="string">"span"</span>,</span><br><span class="line">    effectTag: <span class="number">0</span></span><br><span class="line">    updateQueue: <span class="literal">null</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成后，它看起来像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    stateNode: <span class="keyword">new</span> HTMLSpanElement,</span><br><span class="line">    type: <span class="string">"span"</span>,</span><br><span class="line">    effectTag: <span class="number">4</span>,</span><br><span class="line">    updateQueue: [<span class="string">"children"</span>, <span class="string">"1"</span>],</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>effectTag</code>和<code>updateQueue</code>属性的不同。<code>effectTag</code>由 0 变为 4，4 的二进制是 100，正是更新副作用 tag 对应的值。这是在下面 commit 阶段 React 在这节点上唯一需要做的（指的是执行更新副作用）。<code>udpateQueue</code>顺序中装载了需要被用于更新的内容。</p>
<p>一旦 React 处理完 ClickCounter 和它的孩子，render 阶段就结束了。现在可以在<code>FibeRoot</code>上把已完成的 alternate 树赋值给<code>finishWork</code>属性了。这也是需要被更新到屏幕上的新树。这可能会立即执行，也可能需要等一下，等到浏览器给 React 时间执行时。</p>
<h4 id="影响列表"><a href="#影响列表" class="headerlink" title="影响列表"></a>影响列表</h4><p>在我们的例子中，因为 span 节点和 ClickCounter 组件有副作用，React 会增加一个来联系，链接 span Fiber 节点和<code>HostFiber</code>的<code>firstEffect</code>属性。</p>
<p>React 会在<a href="https://github.com/facebook/react/blob/d5e1bf07d086e4fc1998653331adecddcd0f5274/packages/react-reconciler/src/ReactFiberScheduler.js#L999" target="_blank" rel="noopener"><code>completeUnitOfWork</code></a>方法中构建一个影响列表。在我们的例子中，span 节点需要更新 text、ClickCounter 有回调钩子，其标识出影响的 Fiber 树如下：</p>
<p><img src="/images/react/Inside-Fiber/4.jpg" alt="fiber tree with effect"></p>
<p>如下时带影响的节点构成的线性列表：</p>
<p><img src="/images/react/Inside-Fiber/5.jpg" alt=""></p>
<h4 id="commit-阶段"><a href="#commit-阶段" class="headerlink" title="commit 阶段"></a>commit 阶段</h4><p>这个阶段开始于<code>completeRoot</code>。在开始其他工作之前，它先把<code>FiberRoot</code>上的<code>finishdedWork</code>属性设置为<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.finishedWork = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>不像 render 阶段，commit 阶段总是同步的，所以可以安全更新<code>HostRoot</code>，用以显示 commit 的工作已经开始。</p>
<p>commit 阶段是 React 更新 DOM、调用更新后生命周期方法<code>componentDidUpdate</code>的地方。为了做到这些，它会遍历在 render 阶段构建起来的影响列表，并应用他们。</p>
<p>在 render 阶段，对于 span 和 clickCounter 节点，我们有了以下影响：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">type</span>: ClickCounter, <span class="attr">effectTag</span>: <span class="number">5</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'span'</span>, <span class="attr">effectTag</span>: <span class="number">4</span> &#125;</span><br></pre></td></tr></table></figure>
<p>ClickCounter effect tag 的值是 5，也就是二进制的 101，它定义了更新工作，在类组件中，它被翻译为<code>componentDidUpdate</code>生命周期方法。最后一位被设置，用来表明，对这个 Fiber 节点来说，render 阶段的所有的工作都已完成。</p>
<p>span 的 effect tag，值为 4，也就是二进制的 100，它定义的更新工作是 host 组件的 DOM 更新。对于 span 元素来说，React 需要更新元素的<code>textContent</code>。</p>
<h4 id="应用影响"><a href="#应用影响" class="headerlink" title="应用影响"></a>应用影响</h4><p>让我们来看看 React 如何应用这些影响。用来应用影响的方法，<code>commitRoot</code>，一共有三个子函数构成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params">root, finishedWork</span>) </span>&#123;</span><br><span class="line">  commitBeforeMutationLifecycles();</span><br><span class="line">  commitAllHostEffects();</span><br><span class="line">  root.current = finishedWork;</span><br><span class="line">  commitAllLifeCycles();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个子函数都会实现一个循环，这个循环会遍历影响列表，检查影响类型。如果它找到这个函数被设计应用到的影响，则它会实际应用这个影响。在我们的例子中，它会调用在 ClickCounter 组件上<code>componentDidUpdate</code>生命周期方法、更新 span 元素的 text。</p>
<p>第一个函数 <a href="https://github.com/facebook/react/blob/fefa1269e2a67fa5ef0992d5cc1d6114b7948b7e/packages/react-reconciler/src/ReactFiberCommitWork.js#L183" target="_blank" rel="noopener">commitBeforeMutationLifeCycles</a>会查找<code>Snapshot</code>影响，并调用<code>getSnapshotBeforeUpdate</code>方法。但是，我们不用在 ClickCounter 组件上调用这个方法，因为 React 在 render 阶段并没有添加这个影响。所以在我们的例子中，这个函数什么都不会做。</p>
<h4 id="DOM-更新"><a href="#DOM-更新" class="headerlink" title="DOM 更新"></a>DOM 更新</h4><p>接下来，React 移动到<code>commitAllHostEffects</code>函数。在这里，React 将会把 span 元素的 text 由 0 变为 1。在这里，对于 ClickCounter 组件什么都不会做，因为类组件对应的节点没有任何 DOM 更新。</p>
<p>函数的实现是，它挑选对应类型的影响，并进行对应的操作。在我们的例子中，我们需要更新 span 元素的 text，所以我们会采用<code>Update</code>分支：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostEffects</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (primaryEffectTag) &#123;</span><br><span class="line">      <span class="keyword">case</span> Placement: &#123;...&#125;</span><br><span class="line">      <span class="keyword">case</span> PlacementAndUpdate: &#123;...&#125;</span><br><span class="line">      <span class="keyword">case</span> Update:</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">var</span> current = nextEffect.alternate;</span><br><span class="line">          commitWork(current, nextEffect);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">case</span> Deletion: &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺着<code>commitWork</code>方法而下，我们最终会进入到<code>updateDOMProperties</code>方法，它会使用在 render 阶段添加到 Fiber 节点上的<code>updateQueue</code>来更新 span 元素的<code>texttContent</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDOMProperties</span>(<span class="params">domElement, updatePayload, ...</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; updatePayload.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> propKey = updatePayload[i];</span><br><span class="line">    <span class="keyword">const</span> propValue = updatePayload[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (propKey === STYLE) &#123; ...&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (propKey === DANGEROUSLY_SET_INNER_HTML) &#123;...&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (propKey === CHILDREN) &#123;</span><br><span class="line">      setTextContent(domElement, propValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 DOM 更新被应用之后，React 会把<code>finishedWork</code>树赋值给<code>HostRoot</code>。它会把 alternate 树设置为 current 树：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.current = finishedWork;</span><br></pre></td></tr></table></figure>
<h4 id="调用更新后生命周期钩子"><a href="#调用更新后生命周期钩子" class="headerlink" title="调用更新后生命周期钩子"></a>调用更新后生命周期钩子</h4><p>剩下的最后一个函数是<code>commitAllLifecycles</code>。这是 React 调用更新后生命周期方法的地方。在 render 阶段，React 给 ClickCounter 方法添加了 <code>Update</code>影响。这是<code>commitAllLifecycles</code>函数寻找的并调用<code>componentDidUpdate</code>方法的影响之一：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllLifeCycles</span>(<span class="params">finishedRoot, ...</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> effectTag = nextEffect.effectTag;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (effectTag &amp; (Update | Callback)) &#123;</span><br><span class="line">            <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">            commitLifeCycles(finishedRoot, current, nextEffect, ...);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (effectTag &amp; Ref) &#123;</span><br><span class="line">            commitAttachRef(nextEffect);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nextEffect = nextEffect.nextEffect;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法也会更新<code>refs</code>，但是因为我们没有任何 refs，所以这个功能不会被用到。<a href="https://github.com/facebook/react/blob/e58ecda9a2381735f2c326ee99a1ffa6486321ab/packages/react-reconciler/src/ReactFiberCommitWork.js#L351" target="_blank" rel="noopener"><code>commitLifeCycles</code></a>如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLifeCycles</span>(<span class="params">finishedRoot, current, ...</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> FunctionComponent: &#123;...&#125;</span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> instance = finishedWork.stateNode;</span><br><span class="line">      <span class="keyword">if</span> (finishedWork.effectTag &amp; Update) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">          instance.componentDidMount();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ...</span><br><span class="line">          instance.componentDidUpdate(prevProps, prevState, ...);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostComponent: &#123;...&#125;</span><br><span class="line">    <span class="keyword">case</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以看到，这个方法也是 React 给第一次渲染的组件调用<code>componentDidMount</code>的地方。</p>
<p>以上，就是这些了。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/06/Fiber内部：深入了解React中新的reconciliation算法/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangpanweb"/>
      <meta itemprop="description" content="编程小记"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渊虹小站"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/06/Fiber内部：深入了解React中新的reconciliation算法/" class="post-title-link" itemprop="url">Fiber内部：深入了解React中新的reconciliation算法</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-01-06 17:27:29" itemprop="dateCreated datePublished" datetime="2019-01-06T17:27:29+08:00">2019-01-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-17 11:31:07" itemprop="dateModified" datetime="2019-02-17T11:31:07+08:00">2019-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/译文/" itemprop="url" rel="index"><span itemprop="name">译文</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>此文为译文，原文见：<a href="https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e" target="_blank" rel="noopener">https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e</a></p>
</blockquote>
<p>从 React 元素到 Fiber 节点的一切，如何以及为什么。</p>
<p>React 是一个建立用户界面的 JavaScript 库。其核心是，跟踪组件内状态变化及更新状态至屏幕的机制。在 React 中，我们知道这个过程是<strong>reconciliation</strong>。如果 state 或 props 变化了，UI 上需要重新渲染组件，则调用<code>setState</code>方法，进行框架检查。</p>
<p>React 文档提供了一个对这种机制的高层概览，包括：React 元素的角色、生命周期方法、<code>render</code>方法以及用于组件子元素的 diff 算法。从<code>render</code>方法返回的不可变的 React 元素树也就是为我们所知的“虚拟 DOM”。这个术语在之前有利于解释 React，但是它也造成了一定的迷惑，也没有继续在 React 文档中继续使用。在这篇文章中，我会依旧把它称作 React 元素树。</p>
<p>在 React 元素树中，框架始终保有一个内部实例（组件、DOM 节点等）的组成的树来维持 state。从 React16 版本开始，React 发布了对这种内部实例树的新实现和管理它的新算法——Fiber。想要了解 Fiber 架构带来的好处，可以参考 <a href="https://medium.com/dailyjs/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7" target="_blank" rel="noopener">如何以及为什么 React 在 Fiber 中使用 linked list</a>。</p>
<p>这是这个系列的第一篇，这个系列的目标是让你认识 React 的内部架构。在这篇文章中，我会提供对重要概念和算法数据结构的深度概览。在你拥有这些背景知识之后，我们将去探索那些用于处理 fiber 树的算法和重要函数。这个系列的下一篇文章将会展示 React 如何利用算法来进行第一次渲染、处理状态以及更新属性。这这里开始，我们将进入一些调度细节、子 reconciliation 进程以及建立影响列表的机制。</p>
<p>在这里，我会给你一些相对高阶的知识。阅读它并理解 React 背后的内部运行魔法。如果你想要参与 React，这个系列的文章也会成为一个指引。我深信 reverse-engineering，所以在这里会有很多链接，链接到 React16.6.0 版本的资源。</p>
<p>肯定是有很多需要掌握的，如果你感觉没办法立马理解某些内容，也不要感到有压力。获得有价值的东西确实需要一些时间。注意，你不需要理解以下任何内容，如果你只是使用 React，这篇文章是有关 React 内部运作的文章。</p>
<h4 id="建立背景知识"><a href="#建立背景知识" class="headerlink" title="建立背景知识"></a>建立背景知识</h4><p>这里有一些我会在这个系列里面使用的简单应用。我们有一个按钮，这个按钮很简单，它会增加渲染到屏幕上的一个数字。</p>
<p><img src="/images/react/Inside-Fiber/1.png" alt=""></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      &lt;button key=<span class="string">"1"</span> onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        Update counter</span><br><span class="line">      &lt;<span class="regexp">/button&gt;,</span></span><br><span class="line"><span class="regexp">      &lt;span key="2"&gt;&#123;this.state.count&#125;&lt;/</span>span&gt;</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以在<a href="https://stackblitz.com/edit/react-t4rdmh" target="_blank" rel="noopener">这里</a>看到它。正如你所看到，这是一个简单的组件，从 render 方法返回两个组件，一个 button 一个 span。一旦你点击按钮，组件的状态会在 handler 里面更新，这反过来会导致 span 中的文字更新。</p>
<p>在 reconciliation 期间，React 会执行各种活动。比如，在第一次渲染和状态更新之后，React 会执行以下一些高阶操作：</p>
<ul>
<li>更新<code>ClickCount</code> <code>state</code>中的<code>count</code>属性</li>
<li>检索并比较<code>ClickCount</code>的子元素以及他们的属性</li>
<li>更新<code>span</code>元素的属性</li>
</ul>
<p>在 reconciliation 期间，React 还会执行一些其他操作，比如调用生命周期方法和更新 refs。所以这些活动都集中在 Fiber 架构中进行。活动的类型经常取决于 React 元素的类型。比如说，对于一个类组件，React 需要创建一个实例，而对函数组件则不需要做实例化。正如你所知道，React 中有很多类型的元素，比如，类和函数组件、host 组件（DOM 节点）、portals 等。React 元素的类型通过 createElement 的第一个参数来定义。createElement 函数常用在 render 方法中来创建一个元素。</p>
<p>在我们开始对这些活动以及主要的 fiber 算法之前，让我们先了解一下 React 内部使用的数据结构。</p>
<h4 id="从-React-元素到-Fiber-节点"><a href="#从-React-元素到-Fiber-节点" class="headerlink" title="从 React 元素到 Fiber 节点"></a>从 React 元素到 Fiber 节点</h4><p>React 的每个组件都有一个 UI 展示，我们称之为一个视图或者一个模板，它从 render 方法返回。<code>ClickCounter</code>组件的模板如下</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button key=<span class="string">"1"</span> onClick=&#123;<span class="keyword">this</span>.onClick&#125;&gt;Update counter&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;span key="2"&gt;&#123;this.state.count&#125;&lt;/</span>span&gt;</span><br></pre></td></tr></table></figure>
<h5 id="React-元素"><a href="#React-元素" class="headerlink" title="React 元素"></a>React 元素</h5><p>一旦一个模板通过 JSX 编译器，你会得到一堆 React 元素。这些是真正从 React 组件 render 方法返回的内容，不是 HTML。如果你不使用 JSX，<code>ClickCounter</code>组件的 render 方法可以被改写成下面的样子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            React.createElement(</span><br><span class="line">                <span class="string">'button'</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    key: <span class="string">'1'</span>,</span><br><span class="line">                    onClick: <span class="keyword">this</span>.onClick</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">'Update counter'</span></span><br><span class="line">            ),</span><br><span class="line">            React.createElement(</span><br><span class="line">                <span class="string">'span'</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    key: <span class="string">'2'</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">this</span>.state.count</span><br><span class="line">            )</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 render 方法中对<code>React.createElement</code>的调用会建立两个类似下面的数据结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span>(react.element),</span><br><span class="line">        type: <span class="string">'button'</span>,</span><br><span class="line">        key: <span class="string">"1"</span>,</span><br><span class="line">        props: &#123;</span><br><span class="line">            children: <span class="string">'Update counter'</span>,</span><br><span class="line">            onClick: <span class="function"><span class="params">()</span> =&gt;</span> &#123; ... &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span>(react.element),</span><br><span class="line">        type: <span class="string">'span'</span>,</span><br><span class="line">        key: <span class="string">"2"</span>,</span><br><span class="line">        props: &#123;</span><br><span class="line">            children: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>你可以看到 React 增加了<code>$$typeof</code>属性来标识他们是 React 元素。现在，我们拥有了 type、key、props 属性来描述这个元素。这些值来自我们传入<code>React.createElement</code>的内容。注意 React 如何把文字内容作为 span 和 button 节点的 children 属性进行表示。并且点击处理器被作为了 button 属性的部分。这里还有一些其他 React 元素的属性，比如<code>ref</code>，它超出了这篇文章的讨论范围。</p>
<p><code>ClickCounter</code>这个 React 元素没有 props 和 key：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span>(react.element),</span><br><span class="line">    key: <span class="literal">null</span>,</span><br><span class="line">    props: &#123;&#125;,</span><br><span class="line">    ref: <span class="literal">null</span>,</span><br><span class="line">    type: ClickCounter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Fiber-节点"><a href="#Fiber-节点" class="headerlink" title="Fiber 节点"></a>Fiber 节点</h5><p>在 reconciliation 期间，每个 React 元素 render 方法返回的数据都会被 merge 到一颗 fiber 节点数上。每个 React 元素都会有一个对应的 fiber 节点。和 React 元素不同的是，fiber 并不会在每次渲染时重新创建。这里有可变的数据结构来承载组建的 state 和 DOM。</p>
<p>我们之前讨论过，React 元素的类型会决定框架进行的不同活动。在我们的简单应用中，对类组件<code>ClickCounter</code>，它调用了生命周期方法和 render 方法，对 span host 组件（DOM 节点），它进行了 DOM 转化。每个 React 元素都转化为对应类型的 Fiber 节点，这些类型描述了需要进行的活动。</p>
<p>你可以把一个 fiber 想象成一个数据结构，它代表了需要做的工作，或者换句话说，一个活动的单元。Fiber 架构提供了便捷的方法来跟踪、调度、暂停或停止这些活动。</p>
<p>当一个 React 元素第一次被转化为一个 fiber 节点时，React 会使用来自这个元素的数据来创建一个 fiber，这个动作在 createFiberFromTypeAndProps 函数中。在后续的更新中，React 会复用这个 fiber 节点，利用来自对应 React 元素的数据来更新必须的属性。React 也需要基于 key 属性在层级关系中移动节点，或者当对应 React 元素不再从 render 方法返回时删除它。</p>
<blockquote>
<p>可以参考 ChildReconciler 方法，查看所有活动的列表以及 React 对已存 fiber 节点执行的对应方法。</p>
</blockquote>
<p>因为 React 为每个 React 元素创建了一个 fiber，所以我们有了这些元素组成的树。在我们的简单应用中，它看起来是这样的：</p>
<p><img src="/images/react/Inside-Fiber/2.png" alt=""></p>
<p>所有的 fiber 节点通过一个链接列表互相连接，这个链接列表会使用到 fiber 节点上的以下属性：<code>child</code>、<code>sibling</code>和<code>return</code>。为了了解更多为何采取这种方式的细节，可以参考我的文章，<a href="https://medium.com/dailyjs/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7" target="_blank" rel="noopener">如何以及为什么 React 在 Fiber 中使用链接列表</a>。</p>
<h5 id="进度树中的-current-和-work"><a href="#进度树中的-current-和-work" class="headerlink" title="进度树中的 current 和 work"></a>进度树中的 current 和 work</h5><p>在第一次渲染之后，React 会拥有一个 fiber 树，这个 fiber 树反映了用于渲染 UI 的应用状态。这棵树经常被称作 current。当 React 开始更新时，React 内部会进阿里一个所谓的 workInProgress 树，这棵树反映的是未来即将被更新到屏幕上的状态。</p>
<p>所有对 fiber 的操作都来自于 workInProgress 树。当 React 遍历 current 树时，对于每个已有 fiber 节点，都会创建一个可选的节点来构成 workInProgress 树。这个节点来自 React 元素的 render 方法返回的数据。一旦更新被处理，素有相关工作都完成了，React 会有一个可选的待渲染的树。一旦这颗 workInProgress 树被渲染到屏幕上，他就成了 current 树。</p>
<p>React 的核心原则之一就是一致性。React 总是一次性更新 DOM，它不会只展示部分结果。workInProgress 树所起的作用，是一个“草稿”，它对用户是不可见的，所以 React 可以先处理所有组件，然后把他们的变更渲染到屏幕上。</p>
<p>在源代码中，你会看到很多方法，他们会从 current 和 workInProgress 树上面获得 fiber 节点。这些方法，其中之一的签名如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">current, workInProgress, renderExpirationTime</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>每个 fiber 节点都会存一个引用，指向其他树中对应可能存在的这个节点。在 current 树中的一个节点指向 workInProgress 树的节点，反之亦然。</p>
<h5 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h5><p>我们把 React 中的每个组件都看作一个函数，它使用 state 和 props 来计算需要展示的 UI。每个类似于更改 DOM 或者调用生命周期方法的活动，都应该被看做是一个副作用，或者，简单地说，是一个影响。影响在<a href="https://reactjs.org/docs/hooks-overview.html#%EF%B8%8F-effect-hook" target="_blank" rel="noopener">文档</a>中也有提及：</p>
<blockquote>
<p>你之前可能已经在 React 组件中执行过数据获取、订阅或手动更改 DOM 等活动。我们把这些操作称之为“副作用”（或者简称为“影响”），因为他们能够影响其他组件，而且不能在渲染期间执行。</p>
</blockquote>
<p>如你所见，state 和 props 更新会导致副作用。执行影响是一种操作，fiber 节点是一种非常方便的机制去跟踪除了更新之外的影响。每个 fiber 节点都有与之相关的影响，我们把他们写在<code>effectTag</code>属性中。</p>
<p>所以，在 Fiber 中，影响定义了对于每个实例来说，在更新被处理之后需要执行的工作。对于宿主组件来说（DOM 元素），这些工作包括增加、更新和移除元素。对于类组件来说，React 需要去更新 refs、调用<code>componentDidMount</code>和<code>componentDidUpdate</code>生命周期方法。这里也有一些其他影响，与 fiber 的其他类型相对应。</p>
<h5 id="影响列表"><a href="#影响列表" class="headerlink" title="影响列表"></a>影响列表</h5><p>React 处理更新非常快，为了达到一定成都的效率，它采用了一些非常有趣的机制。其中之一就是，为了快速遍历，它建立了一个包含影响在其中的 fiber 列表。遍历线性列表比遍历树要快很多。这里没有必要在没有副作用的节点上浪费时间。</p>
<p>这个列表的目标是，把有 DOM 更新和其他影响的节点与这些影响关联起来。这个列表是 finishedWork 树的一个子集，而且使用 nextEffect 属性来做连接，而不是在 current 和 workInProgress 树中使用的 child 属性。</p>
<p><a href="https://medium.com/@dan_abramov" target="_blank" rel="noopener">Dan Abramov</a> 提供了一个给影响列表的类比。他喜欢把它比做成一个圣诞树，在这个树上，使用圣诞灯把所有有影响的节点绑在一起。为了把这些可视化，我们可以想象一个拥有以下 fiber 节点的树，在树上，高亮的节点有一些操作需要被执行。比如说，我们的更新导致 c2 被插入到 DOM 总， d2 和 c1 更新属性，b2 出发了生命周期方法。影响列表会把他们连在一起，这样 React 就能够跳过其他节点。</p>
<p>你可以看到，有影响的节点如何被连接在一起。当遍历节点时，React 使用 firstEffect 节点来指向列表的开头。所以上面的图能够被表示成一个线性的列表，如下所示：</p>
<p>正如你所看到的，React 会以从孩子到父母的顺序来执行这些影响。</p>
<h5 id="fiber-节点的根"><a href="#fiber-节点的根" class="headerlink" title="fiber 节点的根"></a>fiber 节点的根</h5><p>每个 React 应用都有一个或多个 DOM 节点作为容器。在沃恩的例子中，是一个有 id 属性的 div 元素。React 给这些每个容器创建一个<a href="https://github.com/facebook/react/blob/0dc0ddc1ef5f90fe48b58f1a1ba753757961fc74/packages/react-reconciler/src/ReactFiberRoot.js#L31" target="_blank" rel="noopener">fiber 根</a>对象。你能够通过使用对这些 DOM 元素的引用来访问到它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fiberRoot = query(<span class="string">"#container"</span>)._reactRootContainer._internalRoot;</span><br></pre></td></tr></table></figure>
<p>fiber 根是 React 存放 fiber 树引用的地方。fiber 树被存放在 fiber 根的 current 属性上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hostRootFiberNode = fiberRoot.current;</span><br></pre></td></tr></table></figure>
<p>fiber 树以一个特殊类型的 fiber 节点开始，它就是 HostRoot。它在内部创建，作为你最上层组件的父亲。在 HostRoot fiber 节点和 FiberRoot 可以通过 stateNode 属性相联系：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fiberRoot.current.stateNode === fiberRoot; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>你可以经由 fiber 根访问最上层的 HostRoot fiber 节点，从而进入 fiber 树。或者你也可以通过组件实例直接获得单个 fiber 节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compInstance._reactInternalFiber;</span><br></pre></td></tr></table></figure>
<h5 id="fiber-节点结构"><a href="#fiber-节点结构" class="headerlink" title="fiber 节点结构"></a>fiber 节点结构</h5><p>现在让我们来看看由<code>ClickCounter</code>组件创建起来的 fibeer 节点的结构，如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    stateNode: <span class="keyword">new</span> ClickCounter,</span><br><span class="line">    type: ClickCounter,</span><br><span class="line">    alternate: <span class="literal">null</span>,</span><br><span class="line">    key: <span class="literal">null</span>,</span><br><span class="line">    updateQueue: <span class="literal">null</span>,</span><br><span class="line">    memoizedState: &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    pendingProps: &#123;&#125;,</span><br><span class="line">    memoizedProps: &#123;&#125;,</span><br><span class="line">    tag: <span class="number">1</span>,</span><br><span class="line">    effectTag: <span class="number">0</span>,</span><br><span class="line">    nextEffect: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及 span DOM 元素的 fiber 节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    stateNode: <span class="keyword">new</span> HTMLSpanElement,</span><br><span class="line">    type: <span class="string">"span"</span>,</span><br><span class="line">    alternate: <span class="literal">null</span>,</span><br><span class="line">    key: <span class="string">"2"</span>,</span><br><span class="line">    updateQueue: <span class="literal">null</span>,</span><br><span class="line">    memoizedState: <span class="literal">null</span>,</span><br><span class="line">    pendingProps: &#123;<span class="attr">children</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    memoizedProps: &#123;<span class="attr">children</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    tag: <span class="number">5</span>,</span><br><span class="line">    effectTag: <span class="number">0</span>,</span><br><span class="line">    nextEffect: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 fiber 节点上有很多属性。在之前有谈到过<code>alternate</code>、<code>affectTag</code>和<code>nextEffect</code>的作用。现在让我们来看看我们为什么需要其他属性。</p>
<h6 id="stateNode"><a href="#stateNode" class="headerlink" title="stateNode"></a>stateNode</h6><p>容纳指向与此 fiber 节点像关联的组件、DOM 节点或者其他 React 元素类型实例的引用。一般来说，我们说，这个属性被用来存放 fiber 节点的本地状态。</p>
<h6 id="type"><a href="#type" class="headerlink" title="type"></a>type</h6><p>定义与这个 fiber 相关的组件或者类。对于类组件，它指向构造器方法，对于 DOM 元素来说，它指向 HTML 标签。我经常使用这个属性，来弄清一个 fiber 节点与什么元素相关联。</p>
<h6 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h6><p>定义 fiber 的<a href="https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/ReactWorkTags.js" target="_blank" rel="noopener">类型</a>。它被用在 reconciliation 算法中，用于决定需要做什么工作。正如之前提到的，根据 React 元素的类型，需要做的工作内容是不同的。函数<a href="https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js#L414" target="_blank" rel="noopener">createFiberFromTypeAndProps</a>会把一个 React 元素映射为与对应类型的 fiber 节点。在我们的应用中，<code>ClickCounter</code>组件的 tag 属性是 1，代表它是一个类组件，对于 span 元素，tag 属性是 5，代表它是一个宿主组件（HostComponent）。</p>
<h6 id="updateQueue"><a href="#updateQueue" class="headerlink" title="updateQueue"></a>updateQueue</h6><p>一个状态更新、回调和 DOM 更新的队列。</p>
<h6 id="memoizedState"><a href="#memoizedState" class="headerlink" title="memoizedState"></a>memoizedState</h6><p>用于创建输出的 fiber 状态。在处理更新时，它反映现在被渲染在屏幕上的状态。</p>
<h6 id="pendingProps"><a href="#pendingProps" class="headerlink" title="pendingProps"></a>pendingProps</h6><p>React 元素中，来自新数据的已经被更新的属性，它之后会被用于子组件或 DOM 元素。</p>
<h6 id="key"><a href="#key" class="headerlink" title="key"></a>key</h6><p>一组子元素中，用于标识哪项已经被更新了、已经被加入或这已经被移除列表的唯一标识符。它和 React 在<a href="https://reactjs.org/docs/lists-and-keys.html#keys" target="_blank" rel="noopener">这里</a>描述的“列表和 key 值”功能相关。</p>
<p>你可以在<a href="https://github.com/facebook/react/blob/6e4f7c788603dac7fccd227a4852c110b072fe16/packages/react-reconciler/src/ReactFiber.js#L78" target="_blank" rel="noopener">这里</a>找到 fiber 节点的完整结构，在上面的描述中我忽略了一堆属性。特别的，我跳过了构成树形数据结构的 child、sibling 和 return，我在之前的文章中有提到过他们。还有一类属性，比如 expirationTime、childExpirationTime 和 mode，他们对调度（Scheduler）很重要。</p>
<h4 id="通用算法"><a href="#通用算法" class="headerlink" title="通用算法"></a>通用算法</h4><p>React 主要在两个阶段执行操作：渲染（render）和提交（commit）。</p>
<p>在第一次渲染阶段，React 把通过<code>setState</code>和<code>React.render</code>把更新推给组件调度，指出在 UI 中需要更新的内容。如果时初次渲染，React 为每个从 render 方法返回的元素创建一个新的 fiber 节点。在之后的更新中，已存 React 元素的 fiber 可以重复使用并更新。这个阶段的结果，是一颗 fiber 节点组成的树，并且节点都被标记上了对应应该执行的副作用。副作用描述了在下面 commit 阶段应该做的事情。在 commit 阶段，React 会拿到标记了副作用的 fiber 树并把他们应用到实例上。它会遍历副作用树，执行 DOM 更新和其他对用户可见的变化。</p>
<p>有一点你需要知道的是，第一次 render 阶段的工作可以被异步执行。React 可以根据可用时间来处理一个或多个 fiber 节点，然后它会保存已完成的工作，转向其他内容。之后它会从它停下的位置继续开始。然而，有时候也会丢弃易完成的工作从头开始。这种暂停可以被实现，是基于一个事实，这个事实是，在 render 阶段所作的工作不会产生任何用户可见的变化（比如 DOM 更新）。相反，之后的 commit 阶段则总是同步的。这是因为在这个极端执行的工作会产生用户可见的变化（比如 DOM 更新）。这也是为什么需要一次性执行他们。</p>
<p>调用生命周期方法是 React 执行一类工作。有些方法在 render 阶段被调用，有些则在 commit 阶段。下面是第一次 render 阶段执行的生命周期列表：</p>
<ul>
<li>[UNSAFE_]componentWillMount (deprecated)</li>
<li>[UNSAFE_]componentWillReceiveProps (deprecated)</li>
<li>getDerivedStateFromProps</li>
<li>shouldComponentUpdate</li>
<li>[UNSAFE_]componentWillUpdate (deprecated)</li>
<li>render</li>
</ul>
<p>正如你所看到的，从 16.3 版本开始，一些老的不建议使用的生命周期方法都被标记上了<code>UNSAFE</code>。在文档中，他们被称作遗留生命周期。在未来的 16.x 版本中，他们会被 deprecated。他们对应<code>UNSAFE</code>后面的方法，会在 17 版本中被移除。你能够在<a href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html" target="_blank" rel="noopener">这里</a>了解到更多相关变化以及建议的迁移方式。</p>
<p>你想知道原因吗？</p>
<p>我们刚才已经知道了，在 render 阶段不产生类似于 DOM 更新的副作用，React 会异步处理更新，异步应用给组件（他们甚至会在多个线程中进行）。然而，被标记了 UNSAFE 的生命周期方法经常会被错误理解，从而被误用。开发者会把一些有副作用的代码放在这些方法里面，这回给新的一步渲染方式造成麻烦。虽然只是 UNSAFE 后面部分的方法被移除，在未来的并发模式中，他们依然很可能会引发问题。</p>
<p>在 commit 阶段执行的生命周期方法列表如下：</p>
<ul>
<li>getSnapshotBeforeUpdate</li>
<li>componentDidMount</li>
<li>componentDidUpdate</li>
<li>componentWillUnmount</li>
</ul>
<p>因为这写方法在同步的 commit 阶段被执行，所以他们可能包含副作用，也可能会接触到 DOM。</p>
<p>现在，我们已经了解到了遍历树和执行工作的通用算法，让我们继续深入一点吧。</p>
<h4 id="render-阶段"><a href="#render-阶段" class="headerlink" title="render 阶段"></a>render 阶段</h4><p>reconciliation 算法使用 <a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L1132" target="_blank" rel="noopener">renderRoot</a>方法，从最顶端的 <code>HostRoot</code>节点开始。React 会跳过已经被处理过的 fiber 节点，直到它找到有未完成工作的节点。比如说，如果你在组件树比较深的层级中调用<code>setState</code>方法，React 会从顶端开始，快速跳过其祖先，知道达到调用 setState 的节点。</p>
<h5 id="工作循环中的主要步骤"><a href="#工作循环中的主要步骤" class="headerlink" title="工作循环中的主要步骤"></a>工作循环中的主要步骤</h5><p>所有的节点都会在<a href="https://github.com/facebook/react/blob/f765f022534958bcf49120bf23bc1aa665e8f651/packages/react-reconciler/src/ReactFiberScheduler.js#L1136" target="_blank" rel="noopener">工作循环</a>中被处理。下面是循环同步部分的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">isYieldy</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isYieldy) &#123;</span><br><span class="line">    <span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，nextUnitOfWork 是一个引用，指向 workInProgress 树上有待执行工作的 fiber 节点。React 会遍历 Fiber 树，它会使用这个变量来知道这里是否还有用待完成工作的 fiber 节点。在 current fiber 被处理完之后，这个遍历会包含一个指向书中下一个 fiber 节点的引用，或者是 null。在这种情况下，React 就会退出工作循环，准备提交这些变化。</p>
<p>在遍历树、初始化和完成工作时，有四个主要的函数：</p>
<ul>
<li>performUnitOfWork</li>
<li>beginWork</li>
<li>completeUnitOfWork</li>
<li>completeWork</li>
</ul>
<p>为了演示他们时怎么被使用的，你可以看看下面遍历 fiber 树的动画。在 demo 中我使用了这些方法的简化实现。每个函数会接受一个待处理的 fiber 节点，在 React 顺着树从上往下的过程中，你可以看到被激活的 fiber 节点在不断变化。你也可以看到算法如何从一个分支切换到另外一个分支。他会先完成子节点的工作然后移动到父节点。</p>
<p><img src="/images/react/Inside-Fiber/3.gif" alt=""></p>
<blockquote>
<p>注意，垂直而下的代表的时兄弟，弯曲而下代表的时父子。比如 b1 没有子节点，b2 有一个子节点 c1</p>
</blockquote>
<p>在这个<a href="https://vimeo.com/302222454" target="_blank" rel="noopener">视频</a>中，你可以暂停播放，仔细看到每个现在处理的节点以及函数的状态。从概念上来说，你可以把“开始”看作成“进入”一个组件，把“完成”看作”走出“这个组件。你也可以在这个<a href="https://stackblitz.com/edit/js-ntqfil?file=index.js" target="_blank" rel="noopener">示例实现</a>中进行探索。</p>
<p>让我们以开始的两个方法<code>performUnitOfWork</code>和<code>beginWork</code>开始：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> next = beginWork(workInProgress);</span><br><span class="line">  <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">    next = completeUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"work performed for "</span> + workInProgress.name);</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>performUnitOfWork</code>接受一个<code>workInProgress</code>树上的 fiber 节点，以调用<code>beginWork</code>方法开始。它是一个 fiber 所需进行所有活动的开端。为了演示的目的，我们简单地把 logfiber 的名字代表需要完成的工作。<code>beginWork</code>方法总是返回一个指针，指向循环中下一个待处理的子节点，或者是 null。</p>
<p>如果这里有下一个子节点，则子节点会被复制给<code>workLoop</code>方法中的<code>nextUnitOfWork</code>这个变量。相反，如果它没有子节点，则 React 知道，它已经到达了分支的最末端，所以它能够结束现在进行的这个节点了。一旦一个节点被完成，它需要转向其兄弟，或者在其兄弟也完成后转向其父母。这些都是在<code>completeUnitOfWork</code>方法中进行的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeUnitOfWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> returnFiber = workInProgress.return;</span><br><span class="line">    <span class="keyword">let</span> siblingFiber = workInProgress.sibling;</span><br><span class="line"></span><br><span class="line">    nextUnitOfWork = completeWork(workInProgress);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (siblingFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If there is a sibling, return it</span></span><br><span class="line">      <span class="comment">// to perform work for this sibling</span></span><br><span class="line">      <span class="keyword">return</span> siblingFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If there's no more work in this returnFiber,</span></span><br><span class="line">      <span class="comment">// continue the loop to complete the parent.</span></span><br><span class="line">      workInProgress = returnFiber;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// We've reached the root.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"work completed for "</span> + workInProgress.name);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以看到，这个方法的概要，就是个大的 while 循环。React 会在一个<code>workInProgress</code>节点没有子节点时进入到这个方法中。在完成现有 fiber 的工作后，它会检查，是否存在节点的兄弟，如果找到，React 会退出这个方法，返回一个指向这个兄弟的指针。这个指针会被复制给<code>nextUnitOfWork</code>变量，React 会开始指向以这个兄弟节点为开始的分支的工作。需要注意的是，在这个时候，React 只是完成了先前那个节点的工作，它并没有完成其父节点的工作。当且仅当所有以其子节点开始的分支都被完成了，才会完成父节点，并进行转向。</p>
<p>正如你所看到的，在<code>performUnitOfWork</code>和<code>completeUnitOfWork</code>是用来做遍历的，二主要的活动那个则发现在<code>beginWork</code>和<code>completeWork</code>中。在这个系列的下面的文章中，我们会学习，对于<code>clikcCounter</code>组件和<code>span</code>节点，进入<code>beginWork</code>和<code>completeWork</code>发生了什么。</p>
<h4 id="commit-阶段"><a href="#commit-阶段" class="headerlink" title="commit 阶段"></a>commit 阶段</h4><p>这个阶段以<a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L2306" target="_blank" rel="noopener">completeRoot</a>函数开始。这里是 React 更新 DOM 和调用更新前、更新后生命周期方法的地方。</p>
<p>当 React 进入到这个阶段时，它会有两棵树以及一个影响列表。第一颗树代表的时渲染在屏幕上的现有状态。另外还有以可替换树，它时在 render 阶段构建起来的。在源码中，它被称为<code>finishedWorkd</code>或<code>workInProgress</code>，它代表这需要被反映在屏幕上的状态。这课替换树和 current 树类似，也是通过 child 和 sibling 指针连接起来的。</p>
<p>继续，这里有一个影响列表——它时 finishedWork 树的子集，之间通过 <code>nextEffect</code>指针相连接。记住，影响列表是 render 阶段的结果。render 阶段的意义就在于决定哪个节点应该被插入、被更新、被删除，哪个组件需要有生命周期方法被调用。这些都是影响列表告诉我们的。它也是一系列需要在 commit 阶段被遍历的节点。</p>
<blockquote>
<p>为了 debug 的目的，current 树可以通过 fiber 根的 <code>current</code>属性访问到。finishedWork 树可以通过 current 树中<code>HostFiber</code>节点的<code>alternate</code>属性访问到。</p>
</blockquote>
<p>在 commit 阶段被调用的主要方法是<code>commitRoot</code>。大致上说，它做了以下工作：</p>
<ul>
<li>在标记了<code>Snapshot</code>影响的节点上调用<code>getSnapshotBeforeUpdate</code>生命周期方法</li>
<li>在标记了<code>Deletion</code>影响的节点上调用<code>componentWillUnmount</code>生命周期方法</li>
<li>执行所有的 DOM 插入、更新和删除</li>
<li>把 finishedWork 树置为 current 树</li>
<li>在标记了<code>Placement</code>影响的节点上调用<code>componentDidMount</code>生命周期方法</li>
<li>在标记了<code>Update</code>影响的节点上调用<code>componentDidUpdate</code>生命周期方法</li>
</ul>
<p>在调用变更前方法<code>getSnapshotBeforeUpdate</code>之后，React 会在一棵树中提交所有的副作用。这会在两部进行。第一步是执行所有的 DOM（host）插入、更新、删除和 ref 卸载。React 会把 finishedWork 树赋值给<code>FiberRoot</code>，使得 finishedWork 树成为 current 树。这会在 commit 阶段第一步完成之后执行，所以在 componentWillUnmount 期间，之前的那棵树还是 current 树。但是在它的执行是在第二步之前，所以在执行 componentDidMount/Update 时，finishedWork 已经时 current 树了。在第二步中，React 会调用所有的其他生命周期方法和 ref 回调。这些方法是在一个单独的步骤中进行的，此时整棵树中所有的替换、更新和删除已经被调用了。</p>
<p>这里有一个执行上述步骤的函数梗概：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params">root, finishedWork</span>) </span>&#123;</span><br><span class="line">  commitBeforeMutationLifecycles();</span><br><span class="line">  commitAllHostEffects();</span><br><span class="line">  root.current = finishedWork;</span><br><span class="line">  commitAllLifeCycles();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个子方法会实现一个循环，这个循环会遍历影响列表并检查影响类型。当它发现子方法需要被用于的影响时，则会在这个影响上调用这个子函数。</p>
<h5 id="变更前生命周期方法"><a href="#变更前生命周期方法" class="headerlink" title="变更前生命周期方法"></a>变更前生命周期方法</h5><p>举例来说，下面的代码展示了一个例子，它会遍历影响树，检查节点是否有<code>Snapshot</code>影响：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationLifecycles</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.effectTag;</span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; Snapshot) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">      commitBeforeMutationLifeCycles(current, nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line">    nextEffect = nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对一个类方法来说，这个影响意味着调用<code>getSnapshotBeforeUpdate</code>生命周期方法。</p>
<h5 id="DOM-更新"><a href="#DOM-更新" class="headerlink" title="DOM 更新"></a>DOM 更新</h5><p><a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L376" target="_blank" rel="noopener">commitAllHostEffects</a>是 React 执行所有 DOM 更新的函数。这个函数定义了对一个节点来说需要进行的操作的类型并执行它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllHostEffects</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (primaryEffectTag) &#123;</span><br><span class="line">        <span class="keyword">case</span> Placement: &#123;</span><br><span class="line">            commitPlacement(nextEffect);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> PlacementAndUpdate: &#123;</span><br><span class="line">            commitPlacement(nextEffect);</span><br><span class="line">            commitWork(current, nextEffect);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Update: &#123;</span><br><span class="line">            commitWork(current, nextEffect);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Deletion: &#123;</span><br><span class="line">            commitDeletion(nextEffect);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有趣的是，React 把 componentWillMount 生命周期方法作为删除过程的一部分在<code>commitDeletion</code>函数中进行。</p>
<h5 id="变更后生命周期方法"><a href="#变更后生命周期方法" class="headerlink" title="变更后生命周期方法"></a>变更后生命周期方法</h5><p><a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L465" target="_blank" rel="noopener">commitAllLifecycles</a>是 React 调用剩余生命周期方法<code>componentDidUpdate</code>和<code>componentDidMount</code>的地方。</p>
<p>We’re finally done！</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/16/React-16-x-Roadmap/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangpanweb"/>
      <meta itemprop="description" content="编程小记"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渊虹小站"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/16/React-16-x-Roadmap/" class="post-title-link" itemprop="url">React 16.x Roadmap</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-12-16 17:48:02" itemprop="dateCreated datePublished" datetime="2018-12-16T17:48:02+08:00">2018-12-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-17 11:35:14" itemprop="dateModified" datetime="2019-02-17T11:35:14+08:00">2019-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/译文/" itemprop="url" rel="index"><span itemprop="name">译文</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>此文翻译自 React 官方博客，地址：<a href="https://reactjs.org/blog/2018/11/27/react-16-roadmap.html。有所删减。" target="_blank" rel="noopener">https://reactjs.org/blog/2018/11/27/react-16-roadmap.html。有所删减。</a></p>
</blockquote>
<p>你可能已经在之前的博客和视频中听说过有关于“Hook”、“Suspense”、“Concurrent Rendering”这些功能。在这篇博客中，我们将关注这些功能如何整合在一起以及在 React 的未来版本中这些功能达到可使用程度的时间线。</p>
<h4 id="tl-dr"><a href="#tl-dr" class="headerlink" title="tl;dr"></a>tl;dr</h4><p>我们计划把 React 的新功能拆分为以下几个里程碑：</p>
<ul>
<li>React16.6 推出 “代码拆分的 Suspense”</li>
<li>16.x 的某个小版本发布 React Hooks（到 2019 年第一季度）</li>
<li>16.x 的某个小版本发布并发模式</li>
<li>16.x 的某个小版本发布“数据获取的 Suspense”</li>
</ul>
<p>（这篇博客的原来版本用的是精确的版本号，但是被改为现在的样子，来反应，在这些版本之间可能需要一些其他小版本的积累来达到这一一个版本）</p>
<p>上面只是预估，详细情况可能会随着时间的流逝而有所变化。在 2019 年我们计划至少有两个项目，他们需要更多探索，还没有具体的发布计划：</p>
<ul>
<li>Modernizing React DOM</li>
<li>Suspense for Server Rendering</li>
</ul>
<p>我们期待在接下来的几个月中对于这些项目的时间线有进一步的确定。</p>
<h4 id="发布时间线"><a href="#发布时间线" class="headerlink" title="发布时间线"></a>发布时间线</h4><p>我们会有一个单独的版本来把这些功能整合到一起，但是我们会在每个功能已经准备好的情况下进行发布，这样你就可以尽快使用它们。单独看某个功能，API 的设计可能看不出什么，这篇博客会展示我们计划的主要部分，来帮助你有一个整体的把握。</p>
<p>逐步发布的策略有助于我们重新定义 API，但是，在过渡时期，某个没有完全完善的功能可能会造成部分疑惑。让我们来看看这些不同的功能对你的 App 来说有什么意义，他们是如何互相关联的，以及你可以在什么时候学习并使用它们。</p>
<h5 id="React16-6（已发布）：代码拆分的-Suspense"><a href="#React16-6（已发布）：代码拆分的-Suspense" class="headerlink" title="React16.6（已发布）：代码拆分的 Suspense"></a>React16.6（已发布）：代码拆分的 Suspense</h5><p><em>Suspense</em>指的是 React 的新功能，当组件在等待某些内容时，它能够暂停渲染，并展示一个加载指示器。在 React16.6 中，Suspense 只支持一种用户场景：使用<code>React.lazy()</code>和<code>&lt;React.Suspense&gt;</code>进行组件的懒加载。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This component is loaded dynamically</span></span><br><span class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./OtherComponent"</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;React.Suspense fallback=&#123;&lt;Spinner /&gt;&#125;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;OtherComponent /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>React.Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>React.lazy()</code>和<code>&lt;React.Suspense&gt;</code>进行代码拆分在  <a href="https://reactjs.org/docs/code-splitting.html#reactlazy" target="_blank" rel="noopener">代码拆分指南</a>中有所描述，你也可以在 <a href="https://medium.com/@pomber/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d" target="_blank" rel="noopener">这篇文章</a> 中知道其他实际解释。</p>
<p>代码拆分是 Suspense 的第一步。对 Suspense 的长期计划也包括让它来处理数据获取的问题（与 Apollo 类似的库进行整合）。除了提供一个更加方面的编程模式外，Suspense 还在并发模式中提供更好的用户体验，在下面的有关话题中我们会提到更多内容。</p>
<p><strong>在 React DOM 中的状态</strong>：React16.6.0 及更高版本可用</p>
<p><strong>在 React DOM Server 中的状态</strong>：在服务器渲染中，Suspense 暂时不可用。我们已经开始在研究新的异步服务端渲染，它包含对 Suspense 的支持。但那是一个大计划，得到 2019 年才能完成。</p>
<p><strong>在 React Native 中的状态</strong>：打包的拆分在 React Native 中并没有很大作用，但是在技术上，当给模块一个 promise 时，没有什么能够阻止<code>Reacct.lazy</code>和<code>&lt;Suspense&gt;</code>起作用。</p>
<p><strong>建议</strong>：如果你进行客户端渲染，我们推荐你广泛使用<code>Reacct.lazy</code>和<code>&lt;Suspense&gt;</code>进行代码拆分。如果你进行服务端渲染，则你不得不等到新的服务端渲染完成后才可以采用。</p>
<h5 id="React-16-x（到-2019-年第一季度）：Hooks"><a href="#React-16-x（到-2019-年第一季度）：Hooks" class="headerlink" title="React 16.x（到 2019 年第一季度）：Hooks"></a>React 16.x（到 2019 年第一季度）：Hooks</h5><p><em>Hooks</em>让你可以在函数组件中使用 state 和生命周期等功能。他们也让你在不增加额外套嵌的情况下在组件间复用状态逻辑。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Declare a new state variable, which we'll call "count"</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>自 11 月份开始已经在 Facebook 内部开始使用 Hooks。Hooks 在 React16.7 的 alpha 版本中可用。他们的 API 距离最终确定时可能会有些变化。</p>
<p>Hooks 代表了我们对未来 React 的预期。它既直接解决了 React 的用户体验问题（再渲染属性时的“层层包裹地狱”和高阶组件，生命周期方法的逻辑复用），也解决了我们在优化 Reac 时遇到的问题（比如说使用编译器内敛组件的困难）。Hooks 没有使类失效。但是，如果 Hooks 发展顺利，在未来的某个大版本中，我们可能会把对类的支持单独拆分到一个包中，以保持 React 默认包的精简。</p>
<p><strong>在 React DOM 中的状态</strong>：支持 Hooks 的第一个<code>react</code>和<code>react-dom</code>版本是<code>16.7.0-alpha.0</code>。我们预计在接下来几个月中会发更多的 alpha 版本。你可以通过安装<code>react@next</code>和<code>react-dom@next</code>来试用他们。别忘记升级你的<code>react-dom</code>，不然 Hooks 不会生效。</p>
<p><strong>在 React DOM Server 中的状态</strong>：同样的 16.7 alpha 版本的<code>react-dom</code>和<code>react-dom/server</code>有对 Hooks 的全面支持。</p>
<p><strong>在 React Native 中的状态</strong>：暂时没有官方方法在 React Native 中使用 Hooks。如果你敢于冒险，可以采用<a href="https://github.com/facebook/react-native/issues/21967" target="_blank" rel="noopener">这篇</a>中提到的非官方方法。里面有一个已知待解决的问题是，<code>useEffect</code>触发过晚。</p>
<p><strong>建议</strong>：如果你已经准备好了，我们推荐你在你写的组件中试用 Hooks。确认你团队中的每个人都赞同使用它们并且对熟悉文档。我们不推荐用 Hooks 重写现在已有的组件，除非你不管怎样都准备重写它们（例如为了修 bug 重写）。在<a href="https://reactjs.org/docs/hooks-faq.html#adoption-strategy" target="_blank" rel="noopener">这里</a>阅读更多使用策略。</p>
<h5 id="React-16-x（到-2019-年第二季度）：并发模式"><a href="#React-16-x（到-2019-年第二季度）：并发模式" class="headerlink" title="React 16.x（到 2019 年第二季度）：并发模式"></a>React 16.x（到 2019 年第二季度）：并发模式</h5><p><em>并发模式</em>，通过在不阻塞主进程的情况下渲染组件树，使得 React 应用变得更加具有适应性。它允许 React 打断一个耗时常的渲染（比如渲染一个新的流）来处理一些高优先级的事务（比如文本输入或鼠标悬浮）。并发模式也通过在快速连接时略过不需要的状态加载来提供 Suspense 的用户体验。</p>
<blockquote>
<p>注意：你可能在之前，听到过被称为“异步模式”的并发模式。我们已经把名字改为并发模式，来强调 React 根据不同优先级来执行任务的能力。这使它和其他异步渲染的方法能够区分开来。</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Two ways to opt in:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Part of an app (not final API)</span></span><br><span class="line">&lt;React.unstable_ConcurrentMode&gt;</span><br><span class="line">  &lt;Something /&gt;</span><br><span class="line">&lt;<span class="regexp">/React.unstable_ConcurrentMode&gt;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 2. Whole app (not final API)</span></span><br><span class="line"><span class="regexp">ReactDOM.unstable_createRoot(domNode).render(&lt;App /</span>&gt;);</span><br></pre></td></tr></table></figure>
<p>暂时没有与并发模式有关的文档。必须要注意的是概念模型在一开始的时候可能会让人觉得不习惯。阐述它的优点、如何使用它以及它的缺点，对于我们来说是高优先级的事情，这也是我们把它称之为稳定的前提条件。在那之前，<a href="https://www.youtube.com/watch?v=ByBPyMBTzM0" target="_blank" rel="noopener">Andrew 的演讲</a>是现有的最好的介绍材料。</p>
<p>并发模式相对于 Hooks 来说还没有经过那么多润色。有些 API 还没有确定，它们也没有按照我们的预期起作用。截止写这篇博客，我们不推荐你使用它，除非是在一些特别早期的实验中使用。在并发模式中，我们预计它没有特别多的 bug，但是需要注意的是，在<code>&lt;React.StrictMode&gt;</code>中产生警告的组件可能不会正常工作。另外一个需要注意的是，我们有时候会把一些在其他代码中产生的性能问题错误的归因到并发模式上。比如说，一个随便防止的<code>setInterval(fn,1)</code>调用在并发模式中会有糟糕的影响。在发布文档中，我们计划发布更多有关确认及修复这类问题的指引。</p>
<p>在我们对 React 的预期中，并发模式是非常大的一个组成部分。对于 CPU 充足的情况下，它能够进行无阻塞渲染，在渲染复杂组件树的同时保持应用的响应。这在我们的<a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html" target="_blank" rel="noopener">JSConf Iceland talk</a>的第一部分有所演示。并发模式也使得 Suspense 表现得更好。它能够防止，在网速足够快的情况下，出现加载指示器一闪而过的情况。在没有亲眼见到的情况下，这很难解释，<a href="https://www.youtube.com/watch?v=ByBPyMBTzM0" target="_blank" rel="noopener">Andrew 的演讲</a>是很好的材料。并发模式依赖于主进程调度器，我们与 Chrome 团队合作，最终把这个功能移入到浏览器本身中。</p>
<p><strong>在 React DOM 中的状态</strong>：在 React16.6 中，有一个带<code>unstable_</code>前缀的不稳定并发模式可以使用，但是我们不推荐你使用它，除非你愿意经常遇到问题或者错误一些功能。16.7 的 alpha 版本包含了不使用<code>unstable_</code>前缀的<code>React.ConcurrentMode</code>和<code>ReactDOM.createRoot</code>，但是在 16.7 中我们大概率会保留前缀，在未来的小版本中才把并发模式成为是稳定的。</p>
<p><strong>在 React DOM Server 中的状态</strong>：并发模式不直接影响服务端渲染，它会在现有的服务端渲染模式下运行。</p>
<p><strong>在 React Native 中的状态</strong>：现有计划是，先推迟并发模式在 React Native 中的实现，直到<a href="https://github.com/react-native-community/discussions-and-proposals/issues/4" target="_blank" rel="noopener">React Fabric</a>计划接近完成。</p>
<p><strong>建议</strong>：如果你希望在未来使用并发模式，记得把一些组件子树包裹在<code>&lt;React.StrictMode&gt;</code>并处理这导致的警告，这是比较好的第一步。一般来说，不要期望老的代码鞥能够立马能够得到兼容。比如，在 Facebook，我们一般会计划在最近的代码库中使用并发模式，在近期的未来中，保持老的代码库依旧使用同步模式。</p>
<h5 id="React16-x（到-2019-年中）：数据获取的-Suspense"><a href="#React16-x（到-2019-年中）：数据获取的-Suspense" class="headerlink" title="React16.x（到 2019 年中）：数据获取的 Suspense"></a>React16.x（到 2019 年中）：数据获取的 Suspense</h5><p>上面提到过，<em>Suspense</em>指的是当组件在等待某些内容是，React 暂停渲染，并展示一个加载指示器的能力。在已经发布的 React16.6 中，Suspense 唯一支持的用户场景是在代码拆分中。在未来的某个小版本中，我们也会提供官方支持，来通过它进行数据获取。我们会提供一个与 Suspense 兼容的、基础“React 缓存”的指导实现，但是你也可以自行撰写。数据获取的库，比如 Apollo 和 Relay 将来可以与 Suspense 进行集成，我们会发布一个简单的集成指引。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React Cache for simple data fetching (not final API)</span></span><br><span class="line"><span class="keyword">import</span> &#123; unstable_createResource &#125; <span class="keyword">from</span> <span class="string">"react-cache"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell React Cache how to fetch your data</span></span><br><span class="line"><span class="keyword">const</span> TodoResource = unstable_createResource(fetchTodo);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Todo</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Suspends until the data is in the cache</span></span><br><span class="line">  <span class="keyword">const</span> todo = TodoResource.read(props.id);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;todo.title&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// Same Suspense component you already use for code splitting</span></span><br><span class="line">    <span class="comment">// would be able to handle data fetching too.</span></span><br><span class="line">    &lt;React.Suspense fallback=&#123;&lt;Spinner /&gt;&#125;&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;<span class="comment">/* Siblings fetch in parallel */</span>&#125;</span><br><span class="line">        &lt;Todo id=<span class="string">"1"</span> /&gt;</span><br><span class="line">        &lt;Todo id=<span class="string">"2"</span> /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>React.Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Other libraries like Apollo and Relay can also</span></span><br><span class="line"><span class="comment">// provide Suspense integrations with similar APIs.</span></span><br></pre></td></tr></table></figure>
<p>针对如何使用 Suspense 获取数据，暂时没有官方文档，但是你能够在<a href="https://youtu.be/ByBPyMBTzM0?t=1312" target="_blank" rel="noopener">这个 talk</a>和<a href="https://github.com/facebook/react/tree/master/fixtures/unstable-async/suspense" target="_blank" rel="noopener">这个小 demo</a>。我们会在接近这次发布的时候写文档，阐述 React Cache 和如何使用你自己写的 Suspense 兼容库。如果你比较好奇，可以在<a href="https://github.com/facebook/react/blob/master/packages/react-cache/src/ReactCache.js" target="_blank" rel="noopener">这里</a>看早先的源码。</p>
<p>低阶 Suspense 机制（暂停渲染和这暂时反馈）预计在 React16.6 版本中稳定。我们已经把他们用在代码拆分中用了几个月。然而，数据获取的高阶 API 还不稳定。React Cache 还在快速变化中，并且还会变动很多次。也有一些低阶 API，他们缺少一些比较好的高阶 API，这使得它们无法被实现。我们不推荐在任何地方使用 React Cache，除了一些非常早起的实验中。注意，React Cache 自身并没有与 React 发布强绑定，但是现有的 alpha 版本缺少基础功能，比如缓存验证，你会遇到一些麻烦。我们计划在这个 React 版本中，达到一些可使用的点。</p>
<p>在最终，我们希望所有的数据获取都通过 Suspense 来实现，但这个还需要很长时间，直到所有的集成项都完成。在实践中，我们期望它能够被增量式采用，通过类似于 Apollo 或者 Relay 这类中间层来实现，而不是直接使用。缺少高阶 API 并不是我们遇到的唯一麻烦——这也有些重要的 UI 模式暂时也不支持，比如在加载视图层级外展示进度展示器。跟之前一样，我们也会在这篇博客中交流我们的进度。</p>
<p><strong>在 React DOM 中的状态</strong>：技术上说，一个兼容的缓存在 React16.6 中已经可以配合<code>&lt;React.Suspense&gt;</code>进行工作了。然而，知道这个小版本发布，我们预计都不会有一个好的缓存实现。如果你敢于冒险，你可以通过查看 React Cache alphas 版本来实现自己的缓存。然而，需要注意的是，在有正式文档前，模型有极大概率被误解。</p>
<p><strong>在 React DOM Server 中的状态</strong>：Suspense 在服务端渲染中暂时不可用。就像之前提到的一样，我们已经开始研究一个新的异步服务端渲染，它会支持 Suspense，但是那是一个非常大的项目，会占用 2019 非常大块的时间来完成。</p>
<p><strong>建议</strong>：到这个小版本发布再来使用 Suspense 进行数据获取。不用使用 16.6 中的 Suspense 功能来实现它，现在还不支持。然而，当数据获取的 Suspense 被官方支持后，你已存的用于代码拆分的<code>&lt;Suspense&gt;</code>组件还是能够展示加载状态的。</p>
<h4 id="其他项目"><a href="#其他项目" class="headerlink" title="其他项目"></a>其他项目</h4><h5 id="现代化-React-DOM"><a href="#现代化-React-DOM" class="headerlink" title="现代化 React DOM"></a>现代化 React DOM</h5><p>我们已经开始调查<a href="https://github.com/facebook/react/issues/13525" target="_blank" rel="noopener">简化和现代化</a>ReactDOM，目标是缩减包的大小并与浏览器行为靠齐。现在说哪些点能够做到达到目的还为时尚早，项目现在还处于探索阶段。我们会在上面的 issue 中交流进度。</p>
<h5 id="服务端渲染的-Suspense"><a href="#服务端渲染的-Suspense" class="headerlink" title="服务端渲染的 Suspense"></a>服务端渲染的 Suspense</h5><p>我们已经开始设计一种支持 Suspense（包括等待服务端异步数据时无重复渲染）、支持渐进式加载、支持在 chunks 中 hydrante 页面内容的新的服务端渲染，以达到更好的用户体验。你能够在<a href="https://www.youtube.com/watch?v=z-6JC0_cOns" target="_blank" rel="noopener">这个 talk</a> 中看到早期原型。新的服务端渲染会成为我们 2019 年的主要关注点，但是现在说它的发布计划还为时尚早。它的开发，依然会在往常一样<a href="https://github.com/facebook/react/pulls?utf8=%E2%9C%93&amp;q=is%3Apr+is%3Aopen+fizz" target="_blank" rel="noopener">在 GitHub 上进行</a>。</p>
<hr>
<p>就是这些了。正如你看到的，这还有很多事情要做，但是我们期待在接下来的几个月中看到更多进步。</p>
<p>我们希望这篇博客能够让你了解我们正在做什么，你现在可以使用什么以及你能够期待未来能够使用什么。在社交媒体上有很多关于新功能的讨论，如果你读了这篇博客，那你就不会错过重要的点了。</p>
<p>我们期待收到反馈，期待在 <a href="https://github.com/reactjs/rfcs" target="_blank" rel="noopener">RFC 仓库</a>、<a href="https://github.com/facebook/react/issues" target="_blank" rel="noopener">issue 跟踪</a>或者 <a href="https://mobile.twitter.com/reactjs" target="_blank" rel="noopener">Twitter</a>上获得你的来信。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/16/react事件处理/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangpanweb"/>
      <meta itemprop="description" content="编程小记"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渊虹小站"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/16/react事件处理/" class="post-title-link" itemprop="url">react事件处理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-12-16 17:39:06" itemprop="dateCreated datePublished" datetime="2018-12-16T17:39:06+08:00">2018-12-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-17 11:35:27" itemprop="dateModified" datetime="2019-02-17T11:35:27+08:00">2019-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/react-doc/" itemprop="url" rel="index"><span itemprop="name">react doc</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>此篇来自于<a href="https://reactjs.org/docs/handling-events.html" target="_blank" rel="noopener">React 官方文档</a>及个人总结</p>
</blockquote>
<h4 id="需注意的点"><a href="#需注意的点" class="headerlink" title="需注意的点"></a>需注意的点</h4><ul>
<li>React 的事件采用的是驼峰式的写法，而不是统一小写</li>
<li>事件处理必须传递函数引用或函数字面量</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;activateLasers&#125;&gt;Activate Lasers&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不能通过返回 false 来阻止事件的默认行为，只能通过显性调用 preventDefault 进行</li>
</ul>
<h4 id="es6-类组件中的事件绑定"><a href="#es6-类组件中的事件绑定" class="headerlink" title="es6 类组件中的事件绑定"></a>es6 类组件中的事件绑定</h4><h5 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h5><ul>
<li>第一种：使用 es6 class 语法时，如果将类的方法作为事件处理函数，则需要进行 this 绑定。原因：在<code>onClick={this.handleClick}</code>中 this.handle 引用正确，于是会变成<code>onClick={function(){this.setState({ isRed: !this.state.isRed })}}</code>，所以会出现在这个方法中 this 为 undefined，于是报错。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isRed</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行 this 绑定</span></span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//ES6 的写法，在类中申明方法，它是一种简写形式：</span></span><br><span class="line">  <span class="comment">// handleClick: function()&#123;&#125;</span></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">isRed</span>: !<span class="keyword">this</span>.state.isRed &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div</span><br><span class="line">        className=<span class="string">"welcome"</span></span><br><span class="line">        style=&#123;&#123; <span class="attr">background</span>: <span class="keyword">this</span>.state.isRed ? <span class="string">"red"</span> : <span class="string">"green"</span> &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        Welcome to <span class="keyword">this</span> websit.</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;change color&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二种</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isRed</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//另一种写法，利用箭头函数，解决 this 绑定的问题，将上面的 this，直接绑定到调用 this.handleClick 的 this，即组件，从而解决了调用绑定的问题。</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">isRed</span>: !<span class="keyword">this</span>.state.isRed &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div</span><br><span class="line">        className=<span class="string">"welcome"</span></span><br><span class="line">        style=&#123;&#123; <span class="attr">background</span>: <span class="keyword">this</span>.state.isRed ? <span class="string">"red"</span> : <span class="string">"green"</span> &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        Welcome to <span class="keyword">this</span> websit.</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;change color&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第三种，在回调中利用箭头函数。注意，在这种写法中，如果回调是作为 props 传递进来的，组件可能会进行额外的渲染。所以比较推荐的是在构造函数中进行绑定或者利用 👆 的方法来写。</li>
</ul>
<h5 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isRed</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">isRed</span>: !<span class="keyword">this</span>.state.isRed &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div</span><br><span class="line">        className=<span class="string">"welcome"</span></span><br><span class="line">        style=&#123;&#123; <span class="attr">background</span>: <span class="keyword">this</span>.state.isRed ? <span class="string">"red"</span> : <span class="string">"green"</span> &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        Welcome to <span class="keyword">this</span> websit.</span><br><span class="line">        &#123;<span class="comment">/* 利用箭头函数解决绑定问题，注意这里 handleClick 后面要加括号。() =&gt; this.handleClick()是一整个函数字面量 *，使用这种写法有个缺点，就是如果这是一个要传递给子组件的属性，则在每次渲染时会重新生成一个函数，子组件会认为属性变更了，从而导致子组件重新渲染，所以这种方式不太推荐 */</span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.handleClick()&#125;&gt;change color&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一种写法，通过 this 绑定后传参</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isRed</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick(id) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">isRed</span>: !<span class="keyword">this</span>.state.isRed &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(id);</span><br><span class="line">    alert(id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div</span><br><span class="line">        className=<span class="string">"welcome"</span></span><br><span class="line">        style=&#123;&#123; <span class="attr">background</span>: <span class="keyword">this</span>.state.isRed ? <span class="string">"red"</span> : <span class="string">"green"</span> &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        Welcome to <span class="keyword">this</span> websit.</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>, <span class="keyword">this</span>.id)&#125;&gt;</span><br><span class="line">          change color</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第三种写法，箭头函数的传参</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isRed</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick(id) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">isRed</span>: !<span class="keyword">this</span>.state.isRed &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(id);</span><br><span class="line">    alert(id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div</span><br><span class="line">        className=<span class="string">"welcome"</span></span><br><span class="line">        style=&#123;&#123; <span class="attr">background</span>: <span class="keyword">this</span>.state.isRed ? <span class="string">"red"</span> : <span class="string">"green"</span> &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        Welcome to <span class="keyword">this</span> websit.</span><br><span class="line">        &lt;button onClick=&#123;e =&gt; <span class="keyword">this</span>.handleClick(<span class="keyword">this</span>.id, e)&#125;&gt;</span><br><span class="line">          change color</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二种写法，特殊写法的传参</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isRed</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">isRed</span>: !<span class="keyword">this</span>.state.isRed &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(id);</span><br><span class="line">    alert(id);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div</span><br><span class="line">        className=<span class="string">"welcome"</span></span><br><span class="line">        style=&#123;&#123; <span class="attr">background</span>: <span class="keyword">this</span>.state.isRed ? <span class="string">"red"</span> : <span class="string">"green"</span> &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        Welcome to <span class="keyword">this</span> websit.</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>, <span class="keyword">this</span>.id)&#125;&gt;</span><br><span class="line">          change color</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数组件中的事件绑定"><a href="#函数组件中的事件绑定" class="headerlink" title="函数组件中的事件绑定"></a>函数组件中的事件绑定</h4><ul>
<li>基本写法。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Add = <span class="function">(<span class="params">&#123; add &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> input;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handeClick = <span class="function"><span class="params">input</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!input.value.trim()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    add(input.value);</span><br><span class="line">    input.value = <span class="string">""</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"add-container"</span>&gt;</span><br><span class="line">      &lt;input ref=&#123;node =&gt; (input = node)&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; handeClick(input)&#125;&gt;Add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以将 handleClick 进行改写，改为比较原始的函数申明写法，不过不推荐。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Add = <span class="function">(<span class="params">&#123; add &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> input;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//改为函数声明的写法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handeClick</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!input.value.trim()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    add(input.value);</span><br><span class="line">    input.value = <span class="string">""</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"add-container"</span>&gt;</span><br><span class="line">      &lt;input ref=&#123;node =&gt; (input = node)&#125; /&gt;</span><br><span class="line">      &#123;<span class="comment">/* 由于需要传递 input，无法直接写成 onClick=&#123;handeClick(input)&#125; */</span>&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; handeClick(input)&#125;&gt;Add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>如上例子中，由于需要传递 input，所以无法直接写成传递字面量的形式，如果不需要传递，则可以直接写引用，如下。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>1111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/01/react-state与生命周期/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangpanweb"/>
      <meta itemprop="description" content="编程小记"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渊虹小站"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/01/react-state与生命周期/" class="post-title-link" itemprop="url">react state与生命周期</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-12-01 11:37:47" itemprop="dateCreated datePublished" datetime="2018-12-01T11:37:47+08:00">2018-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-17 11:35:21" itemprop="dateModified" datetime="2019-02-17T11:35:21+08:00">2019-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/react-doc/" itemprop="url" rel="index"><span itemprop="name">react doc</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>此篇来源于 React 官方文档：<a href="https://reactjs.org/docs。摘录部分有关" target="_blank" rel="noopener">https://reactjs.org/docs。摘录部分有关</a> JSX、元素和组件容易会被忽略的点</p>
</blockquote>
<h4 id="state-与生命周期"><a href="#state-与生命周期" class="headerlink" title="state 与生命周期"></a>state 与生命周期</h4><h5 id="在组件中利用-state-设置定时器"><a href="#在组件中利用-state-设置定时器" class="headerlink" title="在组件中利用 state 设置定时器"></a>在组件中利用 state 设置定时器</h5><ul>
<li>对于以下类组件。每次组件更新的时候，都会调用 render 方法，但是，只要 Cloack 被渲染，之后都只会用到这一个 Clock 实例。这保证了 state 和生命周期的使用。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.props.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于一个包含定时器的组件，当组件第一次被渲染时，需要设定一个定时器；当组件被卸载时，需要清除这个定时器。</li>
<li><code>componentDidMount()</code>方法会在每次组件输出被渲染进 DOM 时执行。</li>
<li>以下组件发生的事情：<ul>
<li>当调用 ReactDOM.render 时，调用 Clock，此时 React 会调用 Clock 的 constructor 构建一个组件实例，在这之中会初始化 state 的值。</li>
<li>React 调用 Clock 的 render 方法，将组件输出渲染进 DOM 中</li>
<li>当组件输出被插入 DOM 中后，React 立马调用<code>componentDidMount()</code>方法，执行方法内的定时器初始化</li>
<li>定时器每秒执行，会调用 tick 方法</li>
</ul>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.timerID = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.tick(), <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timerID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Clock</span> /&gt;</span>, document.getElementById("root"));</span></span><br></pre></td></tr></table></figure>
<h5 id="有关-setState-需知道的三件事"><a href="#有关-setState-需知道的三件事" class="headerlink" title="有关 setState 需知道的三件事"></a>有关 setState 需知道的三件事</h5><ul>
<li>不要直接修改 state 。唯一给<code>this.state</code>赋值的地方就是 constructor 中</li>
<li>状态变更可能是异步的。React 可能会把几个<code>setState</code>的调用合并至一次进行更新。由于<code>this.props</code>和<code>this.state</code>可能会异步更新，所以你不应该依赖他们的值来计算下一个状态值。<code>setState</code>可以接受一个方法，方法第一个参数是前一个状态的值，第二个参数是当前更新被应用时 props 的值。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Wrong</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: state.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<ul>
<li>state 的更新会合并。多个状态值可以在不同的 setState 中进行更新，最终会进行合并更新</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/01/JSX、元素和组件/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangpanweb"/>
      <meta itemprop="description" content="编程小记"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渊虹小站"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/01/JSX、元素和组件/" class="post-title-link" itemprop="url">JSX、元素和组件</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-12-01 11:14:50" itemprop="dateCreated datePublished" datetime="2018-12-01T11:14:50+08:00">2018-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-17 11:31:17" itemprop="dateModified" datetime="2019-02-17T11:31:17+08:00">2019-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/react-doc/" itemprop="url" rel="index"><span itemprop="name">react doc</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>此篇来源于 React 官方文档：<a href="https://reactjs.org/docs/add-react-to-a-website.html" target="_blank" rel="noopener">https://reactjs.org/docs/add-react-to-a-website.html</a></p>
</blockquote>
<h4 id="有关-JSX"><a href="#有关-JSX" class="headerlink" title="有关 JSX"></a>有关 JSX</h4><h5 id="JSX-用作表达式"><a href="#JSX-用作表达式" class="headerlink" title="JSX 用作表达式"></a>JSX 用作表达式</h5><ul>
<li>jsx 是 JavaScript 表达式，所以它可以被用在 JavaScript 语句中，被赋值、接受参数传值以及作为函数返回值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;formatName(user)&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="给-jsx-属性赋值"><a href="#给-jsx-属性赋值" class="headerlink" title="给 jsx 属性赋值"></a>给 jsx 属性赋值</h5><ul>
<li>使用双引号给属性赋予常数值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">tabIndex</span>=<span class="string">"0"</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用大括号给属性赋予 JavaScript 表达式值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>jsx 中的属性采用驼峰式的写法，如 className、tabIndex</li>
</ul>
<h5 id="jsx-防止注入攻击"><a href="#jsx-防止注入攻击" class="headerlink" title="jsx 防止注入攻击"></a>jsx 防止注入攻击</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> title = response.potentiallyMaliciousInput;</span><br><span class="line"><span class="comment">// This is safe:</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用大括号时，React 会把所有插入的值都转为字符串后再进行渲染，从而避免 XSS 攻击</li>
</ul>
<h5 id="jsx-的编译"><a href="#jsx-的编译" class="headerlink" title="jsx 的编译"></a>jsx 的编译</h5><ul>
<li>Babel 会调用 React.createElement 方法来编译 JSX</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">"greeting"</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">  <span class="string">"h1"</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">"greeting"</span> &#125;,</span><br><span class="line">  <span class="string">"Hello, world!"</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终会被编译为类似于以下形式：</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  type: <span class="string">"h1"</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">"greeting"</span>,</span><br><span class="line">    children: <span class="string">"Hello, world!"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="渲染元素"><a href="#渲染元素" class="headerlink" title="渲染元素"></a>渲染元素</h4><ul>
<li>React 组件由 React 元素构成，React 元素都是类似如下的对象。React DOM 会负责将这些对象渲染为实际的 DOM 元素</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  type: <span class="string">"h1"</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">"greeting"</span>,</span><br><span class="line">    children: <span class="string">"Hello, world!"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用 <code>ReactDOM.render</code>进行渲染</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li>React 元素都是不可变的。一个元素一旦创建，则其子元素及属性都不可变更。变动 UI 的方式之一就是新创建一个元素并将它渲染至页面中。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>在元素变更后的重新渲染时，React 只会渲染变更后的内容，未变更的内容不会重复渲染。如上面例子中，虽然每秒钟都会创建一个新元素，但是 ReactDOM 在更新时只会渲染 h2 中变更过的内容。</li>
</ul>
<h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><h5 id="函数组件和类组件"><a href="#函数组件和类组件" class="headerlink" title="函数组件和类组件"></a>函数组件和类组件</h5><ul>
<li>函数组件接受唯一一个对象参数（props 对象），返回一个 React 元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类组件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="组件大写"><a href="#组件大写" class="headerlink" title="组件大写"></a>组件大写</h5><ul>
<li>React 会把小写字母开头的元素当做 DOM 标签，把大写字母开头的才作为组件</li>
</ul>
<h5 id="props-是只读的"><a href="#props-是只读的" class="headerlink" title="props 是只读的"></a>props 是只读的</h5><ul>
<li>所有的 react 组件都必须表现得像纯函数。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/01/非单页面使用react-的方式/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangpanweb"/>
      <meta itemprop="description" content="编程小记"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渊虹小站"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/01/非单页面使用react-的方式/" class="post-title-link" itemprop="url">非单页面使用react 的方式</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-12-01 10:18:16" itemprop="dateCreated datePublished" datetime="2018-12-01T10:18:16+08:00">2018-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-17 11:35:53" itemprop="dateModified" datetime="2019-02-17T11:35:53+08:00">2019-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/react-doc/" itemprop="url" rel="index"><span itemprop="name">react doc</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>此篇来源于 React 官方文档：<a href="https://reactjs.org/docs/state-and-lifecycle.html。摘录部分有关" target="_blank" rel="noopener">https://reactjs.org/docs/state-and-lifecycle.html。摘录部分有关</a> state 容易被忽略的点</p>
</blockquote>
<h5 id="不使用-JSX"><a href="#不使用-JSX" class="headerlink" title="不使用 JSX"></a>不使用 JSX</h5><p>直接在页面中以 script 的方式引用 react 和 react-dom 的 CND 代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"https://unpkg.com/react@16/umd/react.development.js"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">crossorigin</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"https://unpkg.com/react-dom@16/umd/react-dom.development.js"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">crossorigin</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时，无法解析 JSX，故需要使用 React.createElement 的方式来创建组件，具体示例可见：<a href="https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605" target="_blank" rel="noopener">https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605</a></p>
<h5 id="直接在页面中使用-JSX"><a href="#直接在页面中使用-JSX" class="headerlink" title="直接在页面中使用 JSX"></a>直接在页面中使用 JSX</h5><p>在页面上引用 babel 的包代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/babel-standalone@6/babel.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 html 页面的 JS 代码中将 script 的 type 置为 <code>type=&quot;text/babel&quot;</code>，JS 代码写在这个特殊 script 中</p>
<p>在这种方式下：</p>
<p>1、此时无法通过这个 script 引用外部 JS 文件，因为设置 type 后这个 script 已经不是一个作用为引用 JS 的 script 标签了</p>
<p>2、JSX 的编译发生在浏览器中，所以页面加载速度慢，所以它不适合用在生产环境中</p>
<h5 id="实时编译-JSX"><a href="#实时编译-JSX" class="headerlink" title="实时编译 JSX"></a>实时编译 JSX</h5><p>安装 babel-cli@6 和 babel-preset-react-app@3，通过 babel –watch 的功能进行实时编译，将文件编译为浏览器可以直接执行的文件，html 中直接引用编译后的文件</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zhangpanweb</p>
              <p class="site-description motion-element" itemprop="description">编程小记</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">categories</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangpanweb</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.0.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>



  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
