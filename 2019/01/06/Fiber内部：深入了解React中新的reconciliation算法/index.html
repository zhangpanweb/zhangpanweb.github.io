<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=7.0.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="此文为译文，原文见：https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e  从 React 元素到 Fiber 节点的一切，如何以及为什么。 React 是一个建立用户界面的 JavaScript 库。其核">
<meta name="keywords" content="react">
<meta property="og:type" content="article">
<meta property="og:title" content="Fiber内部：深入了解React中新的reconciliation算法">
<meta property="og:url" content="http://yoursite.com/2019/01/06/Fiber内部：深入了解React中新的reconciliation算法/index.html">
<meta property="og:site_name" content="渊虹小站">
<meta property="og:description" content="此文为译文，原文见：https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e  从 React 元素到 Fiber 节点的一切，如何以及为什么。 React 是一个建立用户界面的 JavaScript 库。其核">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://yoursite.com/images/react/Inside-Fiber/1.png">
<meta property="og:image" content="http://yoursite.com/images/react/Inside-Fiber/2.png">
<meta property="og:image" content="http://yoursite.com/images/react/Inside-Fiber/3.gif">
<meta property="og:updated_time" content="2019-02-17T03:31:07.207Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fiber内部：深入了解React中新的reconciliation算法">
<meta name="twitter:description" content="此文为译文，原文见：https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e  从 React 元素到 Fiber 节点的一切，如何以及为什么。 React 是一个建立用户界面的 JavaScript 库。其核">
<meta name="twitter:image" content="http://yoursite.com/images/react/Inside-Fiber/1.png">






  <link rel="canonical" href="http://yoursite.com/2019/01/06/Fiber内部：深入了解React中新的reconciliation算法/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Fiber内部：深入了解React中新的reconciliation算法 | 渊虹小站</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">渊虹小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">无诗无生活，有诗有远方</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/06/Fiber内部：深入了解React中新的reconciliation算法/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangpanweb"/>
      <meta itemprop="description" content="编程小记"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渊虹小站"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Fiber内部：深入了解React中新的reconciliation算法

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-01-06 17:27:29" itemprop="dateCreated datePublished" datetime="2019-01-06T17:27:29+08:00">2019-01-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-17 11:31:07" itemprop="dateModified" datetime="2019-02-17T11:31:07+08:00">2019-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/译文/" itemprop="url" rel="index"><span itemprop="name">译文</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>此文为译文，原文见：<a href="https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e" target="_blank" rel="noopener">https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e</a></p>
</blockquote>
<p>从 React 元素到 Fiber 节点的一切，如何以及为什么。</p>
<p>React 是一个建立用户界面的 JavaScript 库。其核心是，跟踪组件内状态变化及更新状态至屏幕的机制。在 React 中，我们知道这个过程是<strong>reconciliation</strong>。如果 state 或 props 变化了，UI 上需要重新渲染组件，则调用<code>setState</code>方法，进行框架检查。</p>
<p>React 文档提供了一个对这种机制的高层概览，包括：React 元素的角色、生命周期方法、<code>render</code>方法以及用于组件子元素的 diff 算法。从<code>render</code>方法返回的不可变的 React 元素树也就是为我们所知的“虚拟 DOM”。这个术语在之前有利于解释 React，但是它也造成了一定的迷惑，也没有继续在 React 文档中继续使用。在这篇文章中，我会依旧把它称作 React 元素树。</p>
<p>在 React 元素树中，框架始终保有一个内部实例（组件、DOM 节点等）的组成的树来维持 state。从 React16 版本开始，React 发布了对这种内部实例树的新实现和管理它的新算法——Fiber。想要了解 Fiber 架构带来的好处，可以参考 <a href="https://medium.com/dailyjs/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7" target="_blank" rel="noopener">如何以及为什么 React 在 Fiber 中使用 linked list</a>。</p>
<p>这是这个系列的第一篇，这个系列的目标是让你认识 React 的内部架构。在这篇文章中，我会提供对重要概念和算法数据结构的深度概览。在你拥有这些背景知识之后，我们将去探索那些用于处理 fiber 树的算法和重要函数。这个系列的下一篇文章将会展示 React 如何利用算法来进行第一次渲染、处理状态以及更新属性。这这里开始，我们将进入一些调度细节、子 reconciliation 进程以及建立影响列表的机制。</p>
<p>在这里，我会给你一些相对高阶的知识。阅读它并理解 React 背后的内部运行魔法。如果你想要参与 React，这个系列的文章也会成为一个指引。我深信 reverse-engineering，所以在这里会有很多链接，链接到 React16.6.0 版本的资源。</p>
<p>肯定是有很多需要掌握的，如果你感觉没办法立马理解某些内容，也不要感到有压力。获得有价值的东西确实需要一些时间。注意，你不需要理解以下任何内容，如果你只是使用 React，这篇文章是有关 React 内部运作的文章。</p>
<h4 id="建立背景知识"><a href="#建立背景知识" class="headerlink" title="建立背景知识"></a>建立背景知识</h4><p>这里有一些我会在这个系列里面使用的简单应用。我们有一个按钮，这个按钮很简单，它会增加渲染到屏幕上的一个数字。</p>
<p><img src="/images/react/Inside-Fiber/1.png" alt=""></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      &lt;button key=<span class="string">"1"</span> onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        Update counter</span><br><span class="line">      &lt;<span class="regexp">/button&gt;,</span></span><br><span class="line"><span class="regexp">      &lt;span key="2"&gt;&#123;this.state.count&#125;&lt;/</span>span&gt;</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以在<a href="https://stackblitz.com/edit/react-t4rdmh" target="_blank" rel="noopener">这里</a>看到它。正如你所看到，这是一个简单的组件，从 render 方法返回两个组件，一个 button 一个 span。一旦你点击按钮，组件的状态会在 handler 里面更新，这反过来会导致 span 中的文字更新。</p>
<p>在 reconciliation 期间，React 会执行各种活动。比如，在第一次渲染和状态更新之后，React 会执行以下一些高阶操作：</p>
<ul>
<li>更新<code>ClickCount</code> <code>state</code>中的<code>count</code>属性</li>
<li>检索并比较<code>ClickCount</code>的子元素以及他们的属性</li>
<li>更新<code>span</code>元素的属性</li>
</ul>
<p>在 reconciliation 期间，React 还会执行一些其他操作，比如调用生命周期方法和更新 refs。所以这些活动都集中在 Fiber 架构中进行。活动的类型经常取决于 React 元素的类型。比如说，对于一个类组件，React 需要创建一个实例，而对函数组件则不需要做实例化。正如你所知道，React 中有很多类型的元素，比如，类和函数组件、host 组件（DOM 节点）、portals 等。React 元素的类型通过 createElement 的第一个参数来定义。createElement 函数常用在 render 方法中来创建一个元素。</p>
<p>在我们开始对这些活动以及主要的 fiber 算法之前，让我们先了解一下 React 内部使用的数据结构。</p>
<h4 id="从-React-元素到-Fiber-节点"><a href="#从-React-元素到-Fiber-节点" class="headerlink" title="从 React 元素到 Fiber 节点"></a>从 React 元素到 Fiber 节点</h4><p>React 的每个组件都有一个 UI 展示，我们称之为一个视图或者一个模板，它从 render 方法返回。<code>ClickCounter</code>组件的模板如下</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button key=<span class="string">"1"</span> onClick=&#123;<span class="keyword">this</span>.onClick&#125;&gt;Update counter&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;span key="2"&gt;&#123;this.state.count&#125;&lt;/</span>span&gt;</span><br></pre></td></tr></table></figure>
<h5 id="React-元素"><a href="#React-元素" class="headerlink" title="React 元素"></a>React 元素</h5><p>一旦一个模板通过 JSX 编译器，你会得到一堆 React 元素。这些是真正从 React 组件 render 方法返回的内容，不是 HTML。如果你不使用 JSX，<code>ClickCounter</code>组件的 render 方法可以被改写成下面的样子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            React.createElement(</span><br><span class="line">                <span class="string">'button'</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    key: <span class="string">'1'</span>,</span><br><span class="line">                    onClick: <span class="keyword">this</span>.onClick</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">'Update counter'</span></span><br><span class="line">            ),</span><br><span class="line">            React.createElement(</span><br><span class="line">                <span class="string">'span'</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    key: <span class="string">'2'</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">this</span>.state.count</span><br><span class="line">            )</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 render 方法中对<code>React.createElement</code>的调用会建立两个类似下面的数据结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span>(react.element),</span><br><span class="line">        type: <span class="string">'button'</span>,</span><br><span class="line">        key: <span class="string">"1"</span>,</span><br><span class="line">        props: &#123;</span><br><span class="line">            children: <span class="string">'Update counter'</span>,</span><br><span class="line">            onClick: <span class="function"><span class="params">()</span> =&gt;</span> &#123; ... &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span>(react.element),</span><br><span class="line">        type: <span class="string">'span'</span>,</span><br><span class="line">        key: <span class="string">"2"</span>,</span><br><span class="line">        props: &#123;</span><br><span class="line">            children: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>你可以看到 React 增加了<code>$$typeof</code>属性来标识他们是 React 元素。现在，我们拥有了 type、key、props 属性来描述这个元素。这些值来自我们传入<code>React.createElement</code>的内容。注意 React 如何把文字内容作为 span 和 button 节点的 children 属性进行表示。并且点击处理器被作为了 button 属性的部分。这里还有一些其他 React 元素的属性，比如<code>ref</code>，它超出了这篇文章的讨论范围。</p>
<p><code>ClickCounter</code>这个 React 元素没有 props 和 key：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span>(react.element),</span><br><span class="line">    key: <span class="literal">null</span>,</span><br><span class="line">    props: &#123;&#125;,</span><br><span class="line">    ref: <span class="literal">null</span>,</span><br><span class="line">    type: ClickCounter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Fiber-节点"><a href="#Fiber-节点" class="headerlink" title="Fiber 节点"></a>Fiber 节点</h5><p>在 reconciliation 期间，每个 React 元素 render 方法返回的数据都会被 merge 到一颗 fiber 节点数上。每个 React 元素都会有一个对应的 fiber 节点。和 React 元素不同的是，fiber 并不会在每次渲染时重新创建。这里有可变的数据结构来承载组建的 state 和 DOM。</p>
<p>我们之前讨论过，React 元素的类型会决定框架进行的不同活动。在我们的简单应用中，对类组件<code>ClickCounter</code>，它调用了生命周期方法和 render 方法，对 span host 组件（DOM 节点），它进行了 DOM 转化。每个 React 元素都转化为对应类型的 Fiber 节点，这些类型描述了需要进行的活动。</p>
<p>你可以把一个 fiber 想象成一个数据结构，它代表了需要做的工作，或者换句话说，一个活动的单元。Fiber 架构提供了便捷的方法来跟踪、调度、暂停或停止这些活动。</p>
<p>当一个 React 元素第一次被转化为一个 fiber 节点时，React 会使用来自这个元素的数据来创建一个 fiber，这个动作在 createFiberFromTypeAndProps 函数中。在后续的更新中，React 会复用这个 fiber 节点，利用来自对应 React 元素的数据来更新必须的属性。React 也需要基于 key 属性在层级关系中移动节点，或者当对应 React 元素不再从 render 方法返回时删除它。</p>
<blockquote>
<p>可以参考 ChildReconciler 方法，查看所有活动的列表以及 React 对已存 fiber 节点执行的对应方法。</p>
</blockquote>
<p>因为 React 为每个 React 元素创建了一个 fiber，所以我们有了这些元素组成的树。在我们的简单应用中，它看起来是这样的：</p>
<p><img src="/images/react/Inside-Fiber/2.png" alt=""></p>
<p>所有的 fiber 节点通过一个链接列表互相连接，这个链接列表会使用到 fiber 节点上的以下属性：<code>child</code>、<code>sibling</code>和<code>return</code>。为了了解更多为何采取这种方式的细节，可以参考我的文章，<a href="https://medium.com/dailyjs/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7" target="_blank" rel="noopener">如何以及为什么 React 在 Fiber 中使用链接列表</a>。</p>
<h5 id="进度树中的-current-和-work"><a href="#进度树中的-current-和-work" class="headerlink" title="进度树中的 current 和 work"></a>进度树中的 current 和 work</h5><p>在第一次渲染之后，React 会拥有一个 fiber 树，这个 fiber 树反映了用于渲染 UI 的应用状态。这棵树经常被称作 current。当 React 开始更新时，React 内部会进阿里一个所谓的 workInProgress 树，这棵树反映的是未来即将被更新到屏幕上的状态。</p>
<p>所有对 fiber 的操作都来自于 workInProgress 树。当 React 遍历 current 树时，对于每个已有 fiber 节点，都会创建一个可选的节点来构成 workInProgress 树。这个节点来自 React 元素的 render 方法返回的数据。一旦更新被处理，素有相关工作都完成了，React 会有一个可选的待渲染的树。一旦这颗 workInProgress 树被渲染到屏幕上，他就成了 current 树。</p>
<p>React 的核心原则之一就是一致性。React 总是一次性更新 DOM，它不会只展示部分结果。workInProgress 树所起的作用，是一个“草稿”，它对用户是不可见的，所以 React 可以先处理所有组件，然后把他们的变更渲染到屏幕上。</p>
<p>在源代码中，你会看到很多方法，他们会从 current 和 workInProgress 树上面获得 fiber 节点。这些方法，其中之一的签名如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">current, workInProgress, renderExpirationTime</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>每个 fiber 节点都会存一个引用，指向其他树中对应可能存在的这个节点。在 current 树中的一个节点指向 workInProgress 树的节点，反之亦然。</p>
<h5 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h5><p>我们把 React 中的每个组件都看作一个函数，它使用 state 和 props 来计算需要展示的 UI。每个类似于更改 DOM 或者调用生命周期方法的活动，都应该被看做是一个副作用，或者，简单地说，是一个影响。影响在<a href="https://reactjs.org/docs/hooks-overview.html#%EF%B8%8F-effect-hook" target="_blank" rel="noopener">文档</a>中也有提及：</p>
<blockquote>
<p>你之前可能已经在 React 组件中执行过数据获取、订阅或手动更改 DOM 等活动。我们把这些操作称之为“副作用”（或者简称为“影响”），因为他们能够影响其他组件，而且不能在渲染期间执行。</p>
</blockquote>
<p>如你所见，state 和 props 更新会导致副作用。执行影响是一种操作，fiber 节点是一种非常方便的机制去跟踪除了更新之外的影响。每个 fiber 节点都有与之相关的影响，我们把他们写在<code>effectTag</code>属性中。</p>
<p>所以，在 Fiber 中，影响定义了对于每个实例来说，在更新被处理之后需要执行的工作。对于宿主组件来说（DOM 元素），这些工作包括增加、更新和移除元素。对于类组件来说，React 需要去更新 refs、调用<code>componentDidMount</code>和<code>componentDidUpdate</code>生命周期方法。这里也有一些其他影响，与 fiber 的其他类型相对应。</p>
<h5 id="影响列表"><a href="#影响列表" class="headerlink" title="影响列表"></a>影响列表</h5><p>React 处理更新非常快，为了达到一定成都的效率，它采用了一些非常有趣的机制。其中之一就是，为了快速遍历，它建立了一个包含影响在其中的 fiber 列表。遍历线性列表比遍历树要快很多。这里没有必要在没有副作用的节点上浪费时间。</p>
<p>这个列表的目标是，把有 DOM 更新和其他影响的节点与这些影响关联起来。这个列表是 finishedWork 树的一个子集，而且使用 nextEffect 属性来做连接，而不是在 current 和 workInProgress 树中使用的 child 属性。</p>
<p><a href="https://medium.com/@dan_abramov" target="_blank" rel="noopener">Dan Abramov</a> 提供了一个给影响列表的类比。他喜欢把它比做成一个圣诞树，在这个树上，使用圣诞灯把所有有影响的节点绑在一起。为了把这些可视化，我们可以想象一个拥有以下 fiber 节点的树，在树上，高亮的节点有一些操作需要被执行。比如说，我们的更新导致 c2 被插入到 DOM 总， d2 和 c1 更新属性，b2 出发了生命周期方法。影响列表会把他们连在一起，这样 React 就能够跳过其他节点。</p>
<p>你可以看到，有影响的节点如何被连接在一起。当遍历节点时，React 使用 firstEffect 节点来指向列表的开头。所以上面的图能够被表示成一个线性的列表，如下所示：</p>
<p>正如你所看到的，React 会以从孩子到父母的顺序来执行这些影响。</p>
<h5 id="fiber-节点的根"><a href="#fiber-节点的根" class="headerlink" title="fiber 节点的根"></a>fiber 节点的根</h5><p>每个 React 应用都有一个或多个 DOM 节点作为容器。在沃恩的例子中，是一个有 id 属性的 div 元素。React 给这些每个容器创建一个<a href="https://github.com/facebook/react/blob/0dc0ddc1ef5f90fe48b58f1a1ba753757961fc74/packages/react-reconciler/src/ReactFiberRoot.js#L31" target="_blank" rel="noopener">fiber 根</a>对象。你能够通过使用对这些 DOM 元素的引用来访问到它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fiberRoot = query(<span class="string">"#container"</span>)._reactRootContainer._internalRoot;</span><br></pre></td></tr></table></figure>
<p>fiber 根是 React 存放 fiber 树引用的地方。fiber 树被存放在 fiber 根的 current 属性上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hostRootFiberNode = fiberRoot.current;</span><br></pre></td></tr></table></figure>
<p>fiber 树以一个特殊类型的 fiber 节点开始，它就是 HostRoot。它在内部创建，作为你最上层组件的父亲。在 HostRoot fiber 节点和 FiberRoot 可以通过 stateNode 属性相联系：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fiberRoot.current.stateNode === fiberRoot; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>你可以经由 fiber 根访问最上层的 HostRoot fiber 节点，从而进入 fiber 树。或者你也可以通过组件实例直接获得单个 fiber 节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compInstance._reactInternalFiber;</span><br></pre></td></tr></table></figure>
<h5 id="fiber-节点结构"><a href="#fiber-节点结构" class="headerlink" title="fiber 节点结构"></a>fiber 节点结构</h5><p>现在让我们来看看由<code>ClickCounter</code>组件创建起来的 fibeer 节点的结构，如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    stateNode: <span class="keyword">new</span> ClickCounter,</span><br><span class="line">    type: ClickCounter,</span><br><span class="line">    alternate: <span class="literal">null</span>,</span><br><span class="line">    key: <span class="literal">null</span>,</span><br><span class="line">    updateQueue: <span class="literal">null</span>,</span><br><span class="line">    memoizedState: &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    pendingProps: &#123;&#125;,</span><br><span class="line">    memoizedProps: &#123;&#125;,</span><br><span class="line">    tag: <span class="number">1</span>,</span><br><span class="line">    effectTag: <span class="number">0</span>,</span><br><span class="line">    nextEffect: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及 span DOM 元素的 fiber 节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    stateNode: <span class="keyword">new</span> HTMLSpanElement,</span><br><span class="line">    type: <span class="string">"span"</span>,</span><br><span class="line">    alternate: <span class="literal">null</span>,</span><br><span class="line">    key: <span class="string">"2"</span>,</span><br><span class="line">    updateQueue: <span class="literal">null</span>,</span><br><span class="line">    memoizedState: <span class="literal">null</span>,</span><br><span class="line">    pendingProps: &#123;<span class="attr">children</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    memoizedProps: &#123;<span class="attr">children</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    tag: <span class="number">5</span>,</span><br><span class="line">    effectTag: <span class="number">0</span>,</span><br><span class="line">    nextEffect: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 fiber 节点上有很多属性。在之前有谈到过<code>alternate</code>、<code>affectTag</code>和<code>nextEffect</code>的作用。现在让我们来看看我们为什么需要其他属性。</p>
<h6 id="stateNode"><a href="#stateNode" class="headerlink" title="stateNode"></a>stateNode</h6><p>容纳指向与此 fiber 节点像关联的组件、DOM 节点或者其他 React 元素类型实例的引用。一般来说，我们说，这个属性被用来存放 fiber 节点的本地状态。</p>
<h6 id="type"><a href="#type" class="headerlink" title="type"></a>type</h6><p>定义与这个 fiber 相关的组件或者类。对于类组件，它指向构造器方法，对于 DOM 元素来说，它指向 HTML 标签。我经常使用这个属性，来弄清一个 fiber 节点与什么元素相关联。</p>
<h6 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h6><p>定义 fiber 的<a href="https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/ReactWorkTags.js" target="_blank" rel="noopener">类型</a>。它被用在 reconciliation 算法中，用于决定需要做什么工作。正如之前提到的，根据 React 元素的类型，需要做的工作内容是不同的。函数<a href="https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js#L414" target="_blank" rel="noopener">createFiberFromTypeAndProps</a>会把一个 React 元素映射为与对应类型的 fiber 节点。在我们的应用中，<code>ClickCounter</code>组件的 tag 属性是 1，代表它是一个类组件，对于 span 元素，tag 属性是 5，代表它是一个宿主组件（HostComponent）。</p>
<h6 id="updateQueue"><a href="#updateQueue" class="headerlink" title="updateQueue"></a>updateQueue</h6><p>一个状态更新、回调和 DOM 更新的队列。</p>
<h6 id="memoizedState"><a href="#memoizedState" class="headerlink" title="memoizedState"></a>memoizedState</h6><p>用于创建输出的 fiber 状态。在处理更新时，它反映现在被渲染在屏幕上的状态。</p>
<h6 id="pendingProps"><a href="#pendingProps" class="headerlink" title="pendingProps"></a>pendingProps</h6><p>React 元素中，来自新数据的已经被更新的属性，它之后会被用于子组件或 DOM 元素。</p>
<h6 id="key"><a href="#key" class="headerlink" title="key"></a>key</h6><p>一组子元素中，用于标识哪项已经被更新了、已经被加入或这已经被移除列表的唯一标识符。它和 React 在<a href="https://reactjs.org/docs/lists-and-keys.html#keys" target="_blank" rel="noopener">这里</a>描述的“列表和 key 值”功能相关。</p>
<p>你可以在<a href="https://github.com/facebook/react/blob/6e4f7c788603dac7fccd227a4852c110b072fe16/packages/react-reconciler/src/ReactFiber.js#L78" target="_blank" rel="noopener">这里</a>找到 fiber 节点的完整结构，在上面的描述中我忽略了一堆属性。特别的，我跳过了构成树形数据结构的 child、sibling 和 return，我在之前的文章中有提到过他们。还有一类属性，比如 expirationTime、childExpirationTime 和 mode，他们对调度（Scheduler）很重要。</p>
<h4 id="通用算法"><a href="#通用算法" class="headerlink" title="通用算法"></a>通用算法</h4><p>React 主要在两个阶段执行操作：渲染（render）和提交（commit）。</p>
<p>在第一次渲染阶段，React 把通过<code>setState</code>和<code>React.render</code>把更新推给组件调度，指出在 UI 中需要更新的内容。如果时初次渲染，React 为每个从 render 方法返回的元素创建一个新的 fiber 节点。在之后的更新中，已存 React 元素的 fiber 可以重复使用并更新。这个阶段的结果，是一颗 fiber 节点组成的树，并且节点都被标记上了对应应该执行的副作用。副作用描述了在下面 commit 阶段应该做的事情。在 commit 阶段，React 会拿到标记了副作用的 fiber 树并把他们应用到实例上。它会遍历副作用树，执行 DOM 更新和其他对用户可见的变化。</p>
<p>有一点你需要知道的是，第一次 render 阶段的工作可以被异步执行。React 可以根据可用时间来处理一个或多个 fiber 节点，然后它会保存已完成的工作，转向其他内容。之后它会从它停下的位置继续开始。然而，有时候也会丢弃易完成的工作从头开始。这种暂停可以被实现，是基于一个事实，这个事实是，在 render 阶段所作的工作不会产生任何用户可见的变化（比如 DOM 更新）。相反，之后的 commit 阶段则总是同步的。这是因为在这个极端执行的工作会产生用户可见的变化（比如 DOM 更新）。这也是为什么需要一次性执行他们。</p>
<p>调用生命周期方法是 React 执行一类工作。有些方法在 render 阶段被调用，有些则在 commit 阶段。下面是第一次 render 阶段执行的生命周期列表：</p>
<ul>
<li>[UNSAFE_]componentWillMount (deprecated)</li>
<li>[UNSAFE_]componentWillReceiveProps (deprecated)</li>
<li>getDerivedStateFromProps</li>
<li>shouldComponentUpdate</li>
<li>[UNSAFE_]componentWillUpdate (deprecated)</li>
<li>render</li>
</ul>
<p>正如你所看到的，从 16.3 版本开始，一些老的不建议使用的生命周期方法都被标记上了<code>UNSAFE</code>。在文档中，他们被称作遗留生命周期。在未来的 16.x 版本中，他们会被 deprecated。他们对应<code>UNSAFE</code>后面的方法，会在 17 版本中被移除。你能够在<a href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html" target="_blank" rel="noopener">这里</a>了解到更多相关变化以及建议的迁移方式。</p>
<p>你想知道原因吗？</p>
<p>我们刚才已经知道了，在 render 阶段不产生类似于 DOM 更新的副作用，React 会异步处理更新，异步应用给组件（他们甚至会在多个线程中进行）。然而，被标记了 UNSAFE 的生命周期方法经常会被错误理解，从而被误用。开发者会把一些有副作用的代码放在这些方法里面，这回给新的一步渲染方式造成麻烦。虽然只是 UNSAFE 后面部分的方法被移除，在未来的并发模式中，他们依然很可能会引发问题。</p>
<p>在 commit 阶段执行的生命周期方法列表如下：</p>
<ul>
<li>getSnapshotBeforeUpdate</li>
<li>componentDidMount</li>
<li>componentDidUpdate</li>
<li>componentWillUnmount</li>
</ul>
<p>因为这写方法在同步的 commit 阶段被执行，所以他们可能包含副作用，也可能会接触到 DOM。</p>
<p>现在，我们已经了解到了遍历树和执行工作的通用算法，让我们继续深入一点吧。</p>
<h4 id="render-阶段"><a href="#render-阶段" class="headerlink" title="render 阶段"></a>render 阶段</h4><p>reconciliation 算法使用 <a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L1132" target="_blank" rel="noopener">renderRoot</a>方法，从最顶端的 <code>HostRoot</code>节点开始。React 会跳过已经被处理过的 fiber 节点，直到它找到有未完成工作的节点。比如说，如果你在组件树比较深的层级中调用<code>setState</code>方法，React 会从顶端开始，快速跳过其祖先，知道达到调用 setState 的节点。</p>
<h5 id="工作循环中的主要步骤"><a href="#工作循环中的主要步骤" class="headerlink" title="工作循环中的主要步骤"></a>工作循环中的主要步骤</h5><p>所有的节点都会在<a href="https://github.com/facebook/react/blob/f765f022534958bcf49120bf23bc1aa665e8f651/packages/react-reconciler/src/ReactFiberScheduler.js#L1136" target="_blank" rel="noopener">工作循环</a>中被处理。下面是循环同步部分的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">isYieldy</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isYieldy) &#123;</span><br><span class="line">    <span class="keyword">while</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，nextUnitOfWork 是一个引用，指向 workInProgress 树上有待执行工作的 fiber 节点。React 会遍历 Fiber 树，它会使用这个变量来知道这里是否还有用待完成工作的 fiber 节点。在 current fiber 被处理完之后，这个遍历会包含一个指向书中下一个 fiber 节点的引用，或者是 null。在这种情况下，React 就会退出工作循环，准备提交这些变化。</p>
<p>在遍历树、初始化和完成工作时，有四个主要的函数：</p>
<ul>
<li>performUnitOfWork</li>
<li>beginWork</li>
<li>completeUnitOfWork</li>
<li>completeWork</li>
</ul>
<p>为了演示他们时怎么被使用的，你可以看看下面遍历 fiber 树的动画。在 demo 中我使用了这些方法的简化实现。每个函数会接受一个待处理的 fiber 节点，在 React 顺着树从上往下的过程中，你可以看到被激活的 fiber 节点在不断变化。你也可以看到算法如何从一个分支切换到另外一个分支。他会先完成子节点的工作然后移动到父节点。</p>
<p><img src="/images/react/Inside-Fiber/3.gif" alt=""></p>
<blockquote>
<p>注意，垂直而下的代表的时兄弟，弯曲而下代表的时父子。比如 b1 没有子节点，b2 有一个子节点 c1</p>
</blockquote>
<p>在这个<a href="https://vimeo.com/302222454" target="_blank" rel="noopener">视频</a>中，你可以暂停播放，仔细看到每个现在处理的节点以及函数的状态。从概念上来说，你可以把“开始”看作成“进入”一个组件，把“完成”看作”走出“这个组件。你也可以在这个<a href="https://stackblitz.com/edit/js-ntqfil?file=index.js" target="_blank" rel="noopener">示例实现</a>中进行探索。</p>
<p>让我们以开始的两个方法<code>performUnitOfWork</code>和<code>beginWork</code>开始：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> next = beginWork(workInProgress);</span><br><span class="line">  <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">    next = completeUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"work performed for "</span> + workInProgress.name);</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>performUnitOfWork</code>接受一个<code>workInProgress</code>树上的 fiber 节点，以调用<code>beginWork</code>方法开始。它是一个 fiber 所需进行所有活动的开端。为了演示的目的，我们简单地把 logfiber 的名字代表需要完成的工作。<code>beginWork</code>方法总是返回一个指针，指向循环中下一个待处理的子节点，或者是 null。</p>
<p>如果这里有下一个子节点，则子节点会被复制给<code>workLoop</code>方法中的<code>nextUnitOfWork</code>这个变量。相反，如果它没有子节点，则 React 知道，它已经到达了分支的最末端，所以它能够结束现在进行的这个节点了。一旦一个节点被完成，它需要转向其兄弟，或者在其兄弟也完成后转向其父母。这些都是在<code>completeUnitOfWork</code>方法中进行的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeUnitOfWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> returnFiber = workInProgress.return;</span><br><span class="line">    <span class="keyword">let</span> siblingFiber = workInProgress.sibling;</span><br><span class="line"></span><br><span class="line">    nextUnitOfWork = completeWork(workInProgress);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (siblingFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If there is a sibling, return it</span></span><br><span class="line">      <span class="comment">// to perform work for this sibling</span></span><br><span class="line">      <span class="keyword">return</span> siblingFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If there's no more work in this returnFiber,</span></span><br><span class="line">      <span class="comment">// continue the loop to complete the parent.</span></span><br><span class="line">      workInProgress = returnFiber;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// We've reached the root.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"work completed for "</span> + workInProgress.name);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以看到，这个方法的概要，就是个大的 while 循环。React 会在一个<code>workInProgress</code>节点没有子节点时进入到这个方法中。在完成现有 fiber 的工作后，它会检查，是否存在节点的兄弟，如果找到，React 会退出这个方法，返回一个指向这个兄弟的指针。这个指针会被复制给<code>nextUnitOfWork</code>变量，React 会开始指向以这个兄弟节点为开始的分支的工作。需要注意的是，在这个时候，React 只是完成了先前那个节点的工作，它并没有完成其父节点的工作。当且仅当所有以其子节点开始的分支都被完成了，才会完成父节点，并进行转向。</p>
<p>正如你所看到的，在<code>performUnitOfWork</code>和<code>completeUnitOfWork</code>是用来做遍历的，二主要的活动那个则发现在<code>beginWork</code>和<code>completeWork</code>中。在这个系列的下面的文章中，我们会学习，对于<code>clikcCounter</code>组件和<code>span</code>节点，进入<code>beginWork</code>和<code>completeWork</code>发生了什么。</p>
<h4 id="commit-阶段"><a href="#commit-阶段" class="headerlink" title="commit 阶段"></a>commit 阶段</h4><p>这个阶段以<a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L2306" target="_blank" rel="noopener">completeRoot</a>函数开始。这里是 React 更新 DOM 和调用更新前、更新后生命周期方法的地方。</p>
<p>当 React 进入到这个阶段时，它会有两棵树以及一个影响列表。第一颗树代表的时渲染在屏幕上的现有状态。另外还有以可替换树，它时在 render 阶段构建起来的。在源码中，它被称为<code>finishedWorkd</code>或<code>workInProgress</code>，它代表这需要被反映在屏幕上的状态。这课替换树和 current 树类似，也是通过 child 和 sibling 指针连接起来的。</p>
<p>继续，这里有一个影响列表——它时 finishedWork 树的子集，之间通过 <code>nextEffect</code>指针相连接。记住，影响列表是 render 阶段的结果。render 阶段的意义就在于决定哪个节点应该被插入、被更新、被删除，哪个组件需要有生命周期方法被调用。这些都是影响列表告诉我们的。它也是一系列需要在 commit 阶段被遍历的节点。</p>
<blockquote>
<p>为了 debug 的目的，current 树可以通过 fiber 根的 <code>current</code>属性访问到。finishedWork 树可以通过 current 树中<code>HostFiber</code>节点的<code>alternate</code>属性访问到。</p>
</blockquote>
<p>在 commit 阶段被调用的主要方法是<code>commitRoot</code>。大致上说，它做了以下工作：</p>
<ul>
<li>在标记了<code>Snapshot</code>影响的节点上调用<code>getSnapshotBeforeUpdate</code>生命周期方法</li>
<li>在标记了<code>Deletion</code>影响的节点上调用<code>componentWillUnmount</code>生命周期方法</li>
<li>执行所有的 DOM 插入、更新和删除</li>
<li>把 finishedWork 树置为 current 树</li>
<li>在标记了<code>Placement</code>影响的节点上调用<code>componentDidMount</code>生命周期方法</li>
<li>在标记了<code>Update</code>影响的节点上调用<code>componentDidUpdate</code>生命周期方法</li>
</ul>
<p>在调用变更前方法<code>getSnapshotBeforeUpdate</code>之后，React 会在一棵树中提交所有的副作用。这会在两部进行。第一步是执行所有的 DOM（host）插入、更新、删除和 ref 卸载。React 会把 finishedWork 树赋值给<code>FiberRoot</code>，使得 finishedWork 树成为 current 树。这会在 commit 阶段第一步完成之后执行，所以在 componentWillUnmount 期间，之前的那棵树还是 current 树。但是在它的执行是在第二步之前，所以在执行 componentDidMount/Update 时，finishedWork 已经时 current 树了。在第二步中，React 会调用所有的其他生命周期方法和 ref 回调。这些方法是在一个单独的步骤中进行的，此时整棵树中所有的替换、更新和删除已经被调用了。</p>
<p>这里有一个执行上述步骤的函数梗概：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params">root, finishedWork</span>) </span>&#123;</span><br><span class="line">  commitBeforeMutationLifecycles();</span><br><span class="line">  commitAllHostEffects();</span><br><span class="line">  root.current = finishedWork;</span><br><span class="line">  commitAllLifeCycles();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个子方法会实现一个循环，这个循环会遍历影响列表并检查影响类型。当它发现子方法需要被用于的影响时，则会在这个影响上调用这个子函数。</p>
<h5 id="变更前生命周期方法"><a href="#变更前生命周期方法" class="headerlink" title="变更前生命周期方法"></a>变更前生命周期方法</h5><p>举例来说，下面的代码展示了一个例子，它会遍历影响树，检查节点是否有<code>Snapshot</code>影响：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationLifecycles</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.effectTag;</span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; Snapshot) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">      commitBeforeMutationLifeCycles(current, nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line">    nextEffect = nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对一个类方法来说，这个影响意味着调用<code>getSnapshotBeforeUpdate</code>生命周期方法。</p>
<h5 id="DOM-更新"><a href="#DOM-更新" class="headerlink" title="DOM 更新"></a>DOM 更新</h5><p><a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L376" target="_blank" rel="noopener">commitAllHostEffects</a>是 React 执行所有 DOM 更新的函数。这个函数定义了对一个节点来说需要进行的操作的类型并执行它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllHostEffects</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (primaryEffectTag) &#123;</span><br><span class="line">        <span class="keyword">case</span> Placement: &#123;</span><br><span class="line">            commitPlacement(nextEffect);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> PlacementAndUpdate: &#123;</span><br><span class="line">            commitPlacement(nextEffect);</span><br><span class="line">            commitWork(current, nextEffect);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Update: &#123;</span><br><span class="line">            commitWork(current, nextEffect);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Deletion: &#123;</span><br><span class="line">            commitDeletion(nextEffect);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有趣的是，React 把 componentWillMount 生命周期方法作为删除过程的一部分在<code>commitDeletion</code>函数中进行。</p>
<h5 id="变更后生命周期方法"><a href="#变更后生命周期方法" class="headerlink" title="变更后生命周期方法"></a>变更后生命周期方法</h5><p><a href="https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L465" target="_blank" rel="noopener">commitAllLifecycles</a>是 React 调用剩余生命周期方法<code>componentDidUpdate</code>和<code>componentDidMount</code>的地方。</p>
<p>We’re finally done！</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/react/" rel="tag"># react</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/16/React-16-x-Roadmap/" rel="next" title="React 16.x Roadmap">
                <i class="fa fa-chevron-left"></i> React 16.x Roadmap
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/06/深入了解React中state和props的更新/" rel="prev" title="深入了解React中state和props的更新">
                深入了解React中state和props的更新 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zhangpanweb</p>
              <p class="site-description motion-element" itemprop="description">编程小记</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">categories</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#建立背景知识"><span class="nav-number">1.</span> <span class="nav-text">建立背景知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#从-React-元素到-Fiber-节点"><span class="nav-number">2.</span> <span class="nav-text">从 React 元素到 Fiber 节点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#React-元素"><span class="nav-number">2.1.</span> <span class="nav-text">React 元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Fiber-节点"><span class="nav-number">2.2.</span> <span class="nav-text">Fiber 节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进度树中的-current-和-work"><span class="nav-number">2.3.</span> <span class="nav-text">进度树中的 current 和 work</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#副作用"><span class="nav-number">2.4.</span> <span class="nav-text">副作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#影响列表"><span class="nav-number">2.5.</span> <span class="nav-text">影响列表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fiber-节点的根"><span class="nav-number">2.6.</span> <span class="nav-text">fiber 节点的根</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fiber-节点结构"><span class="nav-number">2.7.</span> <span class="nav-text">fiber 节点结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#stateNode"><span class="nav-number">2.7.1.</span> <span class="nav-text">stateNode</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#type"><span class="nav-number">2.7.2.</span> <span class="nav-text">type</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#tag"><span class="nav-number">2.7.3.</span> <span class="nav-text">tag</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#updateQueue"><span class="nav-number">2.7.4.</span> <span class="nav-text">updateQueue</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#memoizedState"><span class="nav-number">2.7.5.</span> <span class="nav-text">memoizedState</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#pendingProps"><span class="nav-number">2.7.6.</span> <span class="nav-text">pendingProps</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#key"><span class="nav-number">2.7.7.</span> <span class="nav-text">key</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通用算法"><span class="nav-number">3.</span> <span class="nav-text">通用算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#render-阶段"><span class="nav-number">4.</span> <span class="nav-text">render 阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#工作循环中的主要步骤"><span class="nav-number">4.1.</span> <span class="nav-text">工作循环中的主要步骤</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#commit-阶段"><span class="nav-number">5.</span> <span class="nav-text">commit 阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#变更前生命周期方法"><span class="nav-number">5.1.</span> <span class="nav-text">变更前生命周期方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DOM-更新"><span class="nav-number">5.2.</span> <span class="nav-text">DOM 更新</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#变更后生命周期方法"><span class="nav-number">5.3.</span> <span class="nav-text">变更后生命周期方法</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangpanweb</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.0.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.0"></script>
<script src="/js/src/post-details.js?v=7.0.0"></script>



  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>



  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
